{"version":3,"sources":["../../../utils/output_parsers/N8nStructuredOutputParser.ts"],"sourcesContent":["import type { Callbacks } from '@langchain/core/callbacks/manager';\nimport { StructuredOutputParser } from 'langchain/output_parsers';\nimport get from 'lodash/get';\nimport type { ISupplyDataFunctions } from 'n8n-workflow';\nimport { NodeConnectionTypes, NodeOperationError } from 'n8n-workflow';\nimport { z } from 'zod';\n\nimport { logAiEvent, unwrapNestedOutput } from '../helpers';\n\nconst STRUCTURED_OUTPUT_KEY = '__structured__output';\nconst STRUCTURED_OUTPUT_OBJECT_KEY = '__structured__output__object';\nconst STRUCTURED_OUTPUT_ARRAY_KEY = '__structured__output__array';\n\nexport class N8nStructuredOutputParser extends StructuredOutputParser<\n\tz.ZodType<object, z.ZodTypeDef, object>\n> {\n\tconstructor(\n\t\tprivate context: ISupplyDataFunctions,\n\t\tzodSchema: z.ZodSchema<object>,\n\t) {\n\t\tsuper(zodSchema);\n\t}\n\n\tlc_namespace = ['langchain', 'output_parsers', 'structured'];\n\n\tasync parse(\n\t\ttext: string,\n\t\t_callbacks?: Callbacks,\n\t\terrorMapper?: (error: Error) => Error,\n\t): Promise<object> {\n\t\tconst { index } = this.context.addInputData(NodeConnectionTypes.AiOutputParser, [\n\t\t\t[{ json: { action: 'parse', text } }],\n\t\t]);\n\n\t\ttry {\n\t\t\tconst jsonString = text.includes('```') ? text.split(/```(?:json)?/)[1] : text;\n\t\t\tconst json = JSON.parse(jsonString.trim());\n\t\t\tconst parsed = await this.schema.parseAsync(json);\n\n\t\t\tlet result = (get(parsed, [STRUCTURED_OUTPUT_KEY, STRUCTURED_OUTPUT_OBJECT_KEY]) ??\n\t\t\t\tget(parsed, [STRUCTURED_OUTPUT_KEY, STRUCTURED_OUTPUT_ARRAY_KEY]) ??\n\t\t\t\tget(parsed, STRUCTURED_OUTPUT_KEY) ??\n\t\t\t\tparsed) as Record<string, unknown>;\n\n\t\t\t// Unwrap any doubly-nested output structures (e.g., {output: {output: {...}}})\n\t\t\tresult = unwrapNestedOutput(result);\n\n\t\t\tlogAiEvent(this.context, 'ai-output-parsed', { text, response: result });\n\n\t\t\tthis.context.addOutputData(NodeConnectionTypes.AiOutputParser, index, [\n\t\t\t\t[{ json: { action: 'parse', response: result } }],\n\t\t\t]);\n\n\t\t\treturn result;\n\t\t} catch (e) {\n\t\t\tconst nodeError = new NodeOperationError(\n\t\t\t\tthis.context.getNode(),\n\t\t\t\t\"Model output doesn't fit required format\",\n\t\t\t\t{\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"To continue the execution when this happens, change the 'On Error' parameter in the root node's settings\",\n\t\t\t\t},\n\t\t\t);\n\n\t\t\t// Add additional context to the error\n\t\t\tif (e instanceof SyntaxError) {\n\t\t\t\tnodeError.context.outputParserFailReason = 'Invalid JSON in model output';\n\t\t\t} else if (\n\t\t\t\t(typeof text === 'string' && text.trim() === '{}') ||\n\t\t\t\t(e instanceof z.ZodError &&\n\t\t\t\t\te.issues?.[0] &&\n\t\t\t\t\te.issues?.[0].code === 'invalid_type' &&\n\t\t\t\t\te.issues?.[0].path?.[0] === 'output' &&\n\t\t\t\t\te.issues?.[0].expected === 'object' &&\n\t\t\t\t\te.issues?.[0].received === 'undefined')\n\t\t\t) {\n\t\t\t\tnodeError.context.outputParserFailReason = 'Model output wrapper is an empty object';\n\t\t\t} else if (e instanceof z.ZodError) {\n\t\t\t\tnodeError.context.outputParserFailReason =\n\t\t\t\t\t'Model output does not match the expected schema';\n\t\t\t}\n\n\t\t\tlogAiEvent(this.context, 'ai-output-parsed', {\n\t\t\t\ttext,\n\t\t\t\tresponse: e.message ?? e,\n\t\t\t});\n\n\t\t\tthis.context.addOutputData(NodeConnectionTypes.AiOutputParser, index, nodeError);\n\t\t\tif (errorMapper) {\n\t\t\t\tthrow errorMapper(e);\n\t\t\t}\n\n\t\t\tthrow nodeError;\n\t\t}\n\t}\n\n\tstatic async fromZodJsonSchema(\n\t\tzodSchema: z.ZodSchema<object>,\n\t\tnodeVersion: number,\n\t\tcontext: ISupplyDataFunctions,\n\t): Promise<N8nStructuredOutputParser> {\n\t\tlet returnSchema: z.ZodType<object, z.ZodTypeDef, object>;\n\t\tif (nodeVersion === 1) {\n\t\t\treturnSchema = z.object({\n\t\t\t\t[STRUCTURED_OUTPUT_KEY]: z\n\t\t\t\t\t.object({\n\t\t\t\t\t\t[STRUCTURED_OUTPUT_OBJECT_KEY]: zodSchema.optional(),\n\t\t\t\t\t\t[STRUCTURED_OUTPUT_ARRAY_KEY]: z.array(zodSchema).optional(),\n\t\t\t\t\t})\n\t\t\t\t\t.describe(\n\t\t\t\t\t\t`Wrapper around the output data. It can only contain ${STRUCTURED_OUTPUT_OBJECT_KEY} or ${STRUCTURED_OUTPUT_ARRAY_KEY} but never both.`,\n\t\t\t\t\t)\n\t\t\t\t\t.refine(\n\t\t\t\t\t\t(data) => {\n\t\t\t\t\t\t\t// Validate that one and only one of the properties exists\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\tBoolean(data[STRUCTURED_OUTPUT_OBJECT_KEY]) !==\n\t\t\t\t\t\t\t\tBoolean(data[STRUCTURED_OUTPUT_ARRAY_KEY])\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\t\t'One and only one of __structured__output__object and __structured__output__array should be present.',\n\t\t\t\t\t\t\tpath: [STRUCTURED_OUTPUT_KEY],\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t});\n\t\t} else if (nodeVersion < 1.3) {\n\t\t\treturnSchema = z.object({\n\t\t\t\toutput: zodSchema.optional(),\n\t\t\t});\n\t\t} else {\n\t\t\treturnSchema = z.object({\n\t\t\t\toutput: zodSchema,\n\t\t\t});\n\t\t}\n\n\t\treturn new N8nStructuredOutputParser(context, returnSchema);\n\t}\n\n\tgetSchema() {\n\t\treturn this.schema;\n\t}\n}\n"],"mappings":"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","names":["get"]}