{"version":3,"sources":["../../utils/N8nTool.ts"],"sourcesContent":["import type { DynamicStructuredToolInput } from '@langchain/core/tools';\nimport { DynamicStructuredTool, DynamicTool } from '@langchain/core/tools';\nimport { StructuredOutputParser } from 'langchain/output_parsers';\nimport type { ISupplyDataFunctions, IDataObject } from 'n8n-workflow';\nimport { NodeConnectionTypes, jsonParse, NodeOperationError } from 'n8n-workflow';\nimport type { ZodTypeAny } from 'zod';\nimport { ZodBoolean, ZodNullable, ZodNumber, ZodObject, ZodOptional } from 'zod';\n\nimport type { ZodObjectAny } from '../types/types';\n\nconst getSimplifiedType = (schema: ZodTypeAny) => {\n\tif (schema instanceof ZodObject) {\n\t\treturn 'object';\n\t} else if (schema instanceof ZodNumber) {\n\t\treturn 'number';\n\t} else if (schema instanceof ZodBoolean) {\n\t\treturn 'boolean';\n\t} else if (schema instanceof ZodNullable || schema instanceof ZodOptional) {\n\t\treturn getSimplifiedType(schema.unwrap());\n\t}\n\n\treturn 'string';\n};\n\nconst getParametersDescription = (parameters: Array<[string, ZodTypeAny]>) =>\n\tparameters\n\t\t.map(\n\t\t\t([name, schema]) =>\n\t\t\t\t`${name}: (description: ${schema.description ?? ''}, type: ${getSimplifiedType(schema)}, required: ${!schema.isOptional()})`,\n\t\t)\n\t\t.join(',\\n ');\n\nexport const prepareFallbackToolDescription = (toolDescription: string, schema: ZodObject<any>) => {\n\tlet description = `${toolDescription}`;\n\n\tconst toolParameters = Object.entries<ZodTypeAny>(schema.shape);\n\n\tif (toolParameters.length) {\n\t\tdescription += `\nTool expects valid stringified JSON object with ${toolParameters.length} properties.\nProperty names with description, type and required status:\n${getParametersDescription(toolParameters)}\nALL parameters marked as required must be provided`;\n\t}\n\n\treturn description;\n};\n\nexport class N8nTool extends DynamicStructuredTool<ZodObjectAny> {\n\tconstructor(\n\t\tprivate context: ISupplyDataFunctions,\n\t\tfields: DynamicStructuredToolInput<ZodObjectAny>,\n\t) {\n\t\tsuper(fields);\n\t}\n\n\tasDynamicTool(): DynamicTool {\n\t\tconst { name, func, schema, context, description } = this;\n\n\t\tconst parser = new StructuredOutputParser(schema);\n\n\t\tconst wrappedFunc = async function (query: string) {\n\t\t\tlet parsedQuery: object;\n\n\t\t\t// First we try to parse the query using the structured parser (Zod schema)\n\t\t\ttry {\n\t\t\t\tparsedQuery = await parser.parse(query);\n\t\t\t} catch (e) {\n\t\t\t\t// If we were unable to parse the query using the schema, we try to gracefully handle it\n\t\t\t\tlet dataFromModel;\n\n\t\t\t\ttry {\n\t\t\t\t\t// First we try to parse a JSON with more relaxed rules\n\t\t\t\t\tdataFromModel = jsonParse<IDataObject>(query, { acceptJSObject: true });\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// In case of error,\n\t\t\t\t\t// If model supplied a simple string instead of an object AND only one parameter expected, we try to recover the object structure\n\t\t\t\t\tif (Object.keys(schema.shape).length === 1) {\n\t\t\t\t\t\tconst parameterName = Object.keys(schema.shape)[0];\n\t\t\t\t\t\tdataFromModel = { [parameterName]: query };\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Finally throw an error if we were unable to parse the query\n\t\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\t\tcontext.getNode(),\n\t\t\t\t\t\t\t`Input is not a valid JSON: ${error.message}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we were able to parse the query with a fallback, we try to validate it using the schema\n\t\t\t\t// Here we will throw an error if the data still does not match the schema\n\t\t\t\tparsedQuery = schema.parse(dataFromModel);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Call tool function with parsed query\n\t\t\t\tconst result = await func(parsedQuery);\n\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\tconst { index } = context.addInputData(NodeConnectionTypes.AiTool, [[{ json: { query } }]]);\n\t\t\t\tvoid context.addOutputData(NodeConnectionTypes.AiTool, index, e);\n\n\t\t\t\treturn e.toString();\n\t\t\t}\n\t\t};\n\n\t\treturn new DynamicTool({\n\t\t\tname,\n\t\t\tdescription: prepareFallbackToolDescription(description, schema),\n\t\t\tfunc: wrappedFunc,\n\t\t});\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,mBAAmD;AACnD,4BAAuC;AAEvC,0BAAmE;AAEnE,iBAA2E;AAI3E,MAAM,oBAAoB,CAAC,WAAuB;AACjD,MAAI,kBAAkB,sBAAW;AAChC,WAAO;AAAA,EACR,WAAW,kBAAkB,sBAAW;AACvC,WAAO;AAAA,EACR,WAAW,kBAAkB,uBAAY;AACxC,WAAO;AAAA,EACR,WAAW,kBAAkB,0BAAe,kBAAkB,wBAAa;AAC1E,WAAO,kBAAkB,OAAO,OAAO,CAAC;AAAA,EACzC;AAEA,SAAO;AACR;AAEA,MAAM,2BAA2B,CAAC,eACjC,WACE;AAAA,EACA,CAAC,CAAC,MAAM,MAAM,MACb,GAAG,IAAI,mBAAmB,OAAO,eAAe,EAAE,WAAW,kBAAkB,MAAM,CAAC,eAAe,CAAC,OAAO,WAAW,CAAC;AAC3H,EACC,KAAK,MAAM;AAEP,MAAM,iCAAiC,CAAC,iBAAyB,WAA2B;AAClG,MAAI,cAAc,GAAG,eAAe;AAEpC,QAAM,iBAAiB,OAAO,QAAoB,OAAO,KAAK;AAE9D,MAAI,eAAe,QAAQ;AAC1B,mBAAe;AAAA,kDACiC,eAAe,MAAM;AAAA;AAAA,EAErE,yBAAyB,cAAc,CAAC;AAAA;AAAA,EAEzC;AAEA,SAAO;AACR;AAEO,MAAM,gBAAgB,mCAAoC;AAAA,EAChE,YACS,SACR,QACC;AACD,UAAM,MAAM;AAHJ;AAAA,EAIT;AAAA,EAEA,gBAA6B;AAC5B,UAAM,EAAE,MAAM,MAAM,QAAQ,SAAS,YAAY,IAAI;AAErD,UAAM,SAAS,IAAI,6CAAuB,MAAM;AAEhD,UAAM,cAAc,eAAgB,OAAe;AAClD,UAAI;AAGJ,UAAI;AACH,sBAAc,MAAM,OAAO,MAAM,KAAK;AAAA,MACvC,SAAS,GAAG;AAEX,YAAI;AAEJ,YAAI;AAEH,8BAAgB,+BAAuB,OAAO,EAAE,gBAAgB,KAAK,CAAC;AAAA,QACvE,SAAS,OAAO;AAGf,cAAI,OAAO,KAAK,OAAO,KAAK,EAAE,WAAW,GAAG;AAC3C,kBAAM,gBAAgB,OAAO,KAAK,OAAO,KAAK,EAAE,CAAC;AACjD,4BAAgB,EAAE,CAAC,aAAa,GAAG,MAAM;AAAA,UAC1C,OAAO;AAEN,kBAAM,IAAI;AAAA,cACT,QAAQ,QAAQ;AAAA,cAChB,8BAA8B,MAAM,OAAO;AAAA,YAC5C;AAAA,UACD;AAAA,QACD;AAIA,sBAAc,OAAO,MAAM,aAAa;AAAA,MACzC;AAEA,UAAI;AAEH,cAAM,SAAS,MAAM,KAAK,WAAW;AAErC,eAAO;AAAA,MACR,SAAS,GAAG;AACX,cAAM,EAAE,MAAM,IAAI,QAAQ,aAAa,wCAAoB,QAAQ,CAAC,CAAC,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC;AAC1F,aAAK,QAAQ,cAAc,wCAAoB,QAAQ,OAAO,CAAC;AAE/D,eAAO,EAAE,SAAS;AAAA,MACnB;AAAA,IACD;AAEA,WAAO,IAAI,yBAAY;AAAA,MACtB;AAAA,MACA,aAAa,+BAA+B,aAAa,MAAM;AAAA,MAC/D,MAAM;AAAA,IACP,CAAC;AAAA,EACF;AACD;","names":[]}