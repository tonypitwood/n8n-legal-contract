{"version":3,"sources":["../../utils/helpers.ts"],"sourcesContent":["import type { BaseChatMessageHistory } from '@langchain/core/chat_history';\nimport type { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport type { BaseLLM } from '@langchain/core/language_models/llms';\nimport type { BaseMessage } from '@langchain/core/messages';\nimport type { Tool } from '@langchain/core/tools';\nimport { Toolkit } from 'langchain/agents';\nimport type { BaseChatMemory } from 'langchain/memory';\nimport { NodeConnectionTypes, NodeOperationError, jsonStringify } from 'n8n-workflow';\nimport type {\n\tAiEvent,\n\tIDataObject,\n\tIExecuteFunctions,\n\tISupplyDataFunctions,\n\tIWebhookFunctions,\n} from 'n8n-workflow';\n\nimport { N8nTool } from './N8nTool';\n\nfunction hasMethods<T>(obj: unknown, ...methodNames: Array<string | symbol>): obj is T {\n\treturn methodNames.every(\n\t\t(methodName) =>\n\t\t\ttypeof obj === 'object' &&\n\t\t\tobj !== null &&\n\t\t\tmethodName in obj &&\n\t\t\ttypeof (obj as Record<string | symbol, unknown>)[methodName] === 'function',\n\t);\n}\n\nexport function getMetadataFiltersValues(\n\tctx: IExecuteFunctions | ISupplyDataFunctions,\n\titemIndex: number,\n): Record<string, never> | undefined {\n\tconst options = ctx.getNodeParameter('options', itemIndex, {});\n\n\tif (options.metadata) {\n\t\tconst { metadataValues: metadata } = options.metadata as {\n\t\t\tmetadataValues: Array<{\n\t\t\t\tname: string;\n\t\t\t\tvalue: string;\n\t\t\t}>;\n\t\t};\n\t\tif (metadata.length > 0) {\n\t\t\treturn metadata.reduce((acc, { name, value }) => ({ ...acc, [name]: value }), {});\n\t\t}\n\t}\n\n\tif (options.searchFilterJson) {\n\t\treturn ctx.getNodeParameter('options.searchFilterJson', itemIndex, '', {\n\t\t\tensureType: 'object',\n\t\t}) as Record<string, never>;\n\t}\n\n\treturn undefined;\n}\n\nexport function isBaseChatMemory(obj: unknown) {\n\treturn hasMethods<BaseChatMemory>(obj, 'loadMemoryVariables', 'saveContext');\n}\n\nexport function isBaseChatMessageHistory(obj: unknown) {\n\treturn hasMethods<BaseChatMessageHistory>(obj, 'getMessages', 'addMessage');\n}\n\nexport function isChatInstance(model: unknown): model is BaseChatModel {\n\tconst namespace = (model as BaseLLM)?.lc_namespace ?? [];\n\n\treturn namespace.includes('chat_models');\n}\n\nexport function isToolsInstance(model: unknown): model is Tool {\n\tconst namespace = (model as Tool)?.lc_namespace ?? [];\n\n\treturn namespace.includes('tools');\n}\n\nexport function getPromptInputByType(options: {\n\tctx: IExecuteFunctions | ISupplyDataFunctions;\n\ti: number;\n\tpromptTypeKey: string;\n\tinputKey: string;\n}) {\n\tconst { ctx, i, promptTypeKey, inputKey } = options;\n\tconst promptType = ctx.getNodeParameter(promptTypeKey, i, 'define') as string;\n\n\tlet input;\n\tif (promptType === 'auto') {\n\t\tinput = ctx.evaluateExpression('{{ $json[\"chatInput\"] }}', i) as string;\n\t} else {\n\t\tinput = ctx.getNodeParameter(inputKey, i) as string;\n\t}\n\n\tif (input === undefined) {\n\t\tthrow new NodeOperationError(ctx.getNode(), 'No prompt specified', {\n\t\t\tdescription:\n\t\t\t\t\"Expected to find the prompt in an input field called 'chatInput' (this is what the chat trigger node outputs). To use something else, change the 'Prompt' parameter\",\n\t\t});\n\t}\n\n\treturn input;\n}\n\nexport function getSessionId(\n\tctx: ISupplyDataFunctions | IWebhookFunctions,\n\titemIndex: number,\n\tselectorKey = 'sessionIdType',\n\tautoSelect = 'fromInput',\n\tcustomKey = 'sessionKey',\n) {\n\tlet sessionId = '';\n\tconst selectorType = ctx.getNodeParameter(selectorKey, itemIndex) as string;\n\n\tif (selectorType === autoSelect) {\n\t\t// If memory node is used in webhook like node(like chat trigger node), it doesn't have access to evaluateExpression\n\t\t// so we try to extract sessionId from the bodyData\n\t\tif ('getBodyData' in ctx) {\n\t\t\tconst bodyData = ctx.getBodyData() ?? {};\n\t\t\tsessionId = bodyData.sessionId as string;\n\t\t} else {\n\t\t\tsessionId = ctx.evaluateExpression('{{ $json.sessionId }}', itemIndex) as string;\n\n\t\t\t// try to get sessionId from chat trigger\n\t\t\tif (!sessionId || sessionId === undefined) {\n\t\t\t\ttry {\n\t\t\t\t\tconst chatTrigger = ctx.getChatTrigger();\n\n\t\t\t\t\tif (chatTrigger) {\n\t\t\t\t\t\tsessionId = ctx.evaluateExpression(\n\t\t\t\t\t\t\t`{{ $('${chatTrigger.name}').first().json.sessionId }}`,\n\t\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\t) as string;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {}\n\t\t\t}\n\t\t}\n\n\t\tif (sessionId === '' || sessionId === undefined) {\n\t\t\tthrow new NodeOperationError(ctx.getNode(), 'No session ID found', {\n\t\t\t\tdescription:\n\t\t\t\t\t\"Expected to find the session ID in an input field called 'sessionId' (this is what the chat trigger node outputs). To use something else, change the 'Session ID' parameter\",\n\t\t\t\titemIndex,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tsessionId = ctx.getNodeParameter(customKey, itemIndex, '') as string;\n\t\tif (sessionId === '' || sessionId === undefined) {\n\t\t\tthrow new NodeOperationError(ctx.getNode(), 'Key parameter is empty', {\n\t\t\t\tdescription:\n\t\t\t\t\t\"Provide a key to use as session ID in the 'Key' parameter or use the 'Connected Chat Trigger Node' option to use the session ID from your Chat Trigger\",\n\t\t\t\titemIndex,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn sessionId;\n}\n\nexport function logAiEvent(\n\texecuteFunctions: IExecuteFunctions | ISupplyDataFunctions,\n\tevent: AiEvent,\n\tdata?: IDataObject,\n) {\n\ttry {\n\t\texecuteFunctions.logAiEvent(event, data ? jsonStringify(data) : undefined);\n\t} catch (error) {\n\t\texecuteFunctions.logger.debug(`Error logging AI event: ${event}`);\n\t}\n}\n\nexport function serializeChatHistory(chatHistory: BaseMessage[]): string {\n\treturn chatHistory\n\t\t.map((chatMessage) => {\n\t\t\tif (chatMessage._getType() === 'human') {\n\t\t\t\treturn `Human: ${chatMessage.content}`;\n\t\t\t} else if (chatMessage._getType() === 'ai') {\n\t\t\t\treturn `Assistant: ${chatMessage.content}`;\n\t\t\t} else {\n\t\t\t\treturn `${chatMessage.content}`;\n\t\t\t}\n\t\t})\n\t\t.join('\\n');\n}\n\nexport function escapeSingleCurlyBrackets(text?: string): string | undefined {\n\tif (text === undefined) return undefined;\n\n\tlet result = text;\n\n\tresult = result\n\t\t// First handle triple brackets to avoid interference with double brackets\n\t\t.replace(/(?<!{){{{(?!{)/g, '{{{{')\n\t\t.replace(/(?<!})}}}(?!})/g, '}}}}')\n\t\t// Then handle single brackets, but only if they're not part of double brackets\n\t\t// Convert single { to {{ if it's not already part of {{ or {{{\n\t\t.replace(/(?<!{){(?!{)/g, '{{')\n\t\t// Convert single } to }} if it's not already part of }} or }}}\n\t\t.replace(/(?<!})}(?!})/g, '}}');\n\n\treturn result;\n}\n\nexport const getConnectedTools = async (\n\tctx: IExecuteFunctions | IWebhookFunctions | ISupplyDataFunctions,\n\tenforceUniqueNames: boolean,\n\tconvertStructuredTool: boolean = true,\n\tescapeCurlyBrackets: boolean = false,\n) => {\n\tconst connectedTools = (\n\t\t((await ctx.getInputConnectionData(NodeConnectionTypes.AiTool, 0)) as Array<Toolkit | Tool>) ??\n\t\t[]\n\t).flatMap((toolOrToolkit) => {\n\t\tif (toolOrToolkit instanceof Toolkit) {\n\t\t\treturn toolOrToolkit.getTools() as Tool[];\n\t\t}\n\n\t\treturn toolOrToolkit;\n\t});\n\n\tif (!enforceUniqueNames) return connectedTools;\n\n\tconst seenNames = new Set<string>();\n\n\tconst finalTools: Tool[] = [];\n\n\tfor (const tool of connectedTools) {\n\t\tconst { name } = tool;\n\t\tif (seenNames.has(name)) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tctx.getNode(),\n\t\t\t\t`You have multiple tools with the same name: '${name}', please rename them to avoid conflicts`,\n\t\t\t);\n\t\t}\n\t\tseenNames.add(name);\n\n\t\tif (escapeCurlyBrackets) {\n\t\t\ttool.description = escapeSingleCurlyBrackets(tool.description) ?? tool.description;\n\t\t}\n\n\t\tif (convertStructuredTool && tool instanceof N8nTool) {\n\t\t\tfinalTools.push(tool.asDynamicTool());\n\t\t} else {\n\t\t\tfinalTools.push(tool);\n\t\t}\n\t}\n\n\treturn finalTools;\n};\n\n/**\n * Sometimes model output is wrapped in an additional object property.\n * This function unwraps the output if it is in the format { output: { output: { ... } } }\n */\nexport function unwrapNestedOutput(output: Record<string, unknown>): Record<string, unknown> {\n\tif (\n\t\t'output' in output &&\n\t\tObject.keys(output).length === 1 &&\n\t\ttypeof output.output === 'object' &&\n\t\toutput.output !== null &&\n\t\t'output' in output.output &&\n\t\tObject.keys(output.output).length === 1\n\t) {\n\t\treturn output.output as Record<string, unknown>;\n\t}\n\n\treturn output;\n}\n\n/**\n * Detects if a text contains a character that repeats sequentially for a specified threshold.\n * This is used to prevent performance issues with tiktoken on highly repetitive content.\n * @param text The text to check\n * @param threshold The minimum number of sequential repeats to detect (default: 1000)\n * @returns true if a character repeats sequentially for at least the threshold amount\n */\nexport function hasLongSequentialRepeat(text: string, threshold = 1000): boolean {\n\ttry {\n\t\t// Validate inputs\n\t\tif (\n\t\t\ttext === null ||\n\t\t\ttypeof text !== 'string' ||\n\t\t\ttext.length === 0 ||\n\t\t\tthreshold <= 0 ||\n\t\t\ttext.length < threshold\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\t// Use string iterator to avoid creating array copy (memory efficient)\n\t\tconst iterator = text[Symbol.iterator]();\n\t\tlet prev = iterator.next();\n\n\t\tif (prev.done) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet count = 1;\n\t\tfor (const char of iterator) {\n\t\t\tif (char === prev.value) {\n\t\t\t\tcount++;\n\t\t\t\tif (count >= threshold) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcount = 1;\n\t\t\t\tprev = { value: char, done: false };\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t} catch (error) {\n\t\t// On any error, return false to allow normal processing\n\t\treturn false;\n\t}\n}\n"],"mappings":"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","names":[]}