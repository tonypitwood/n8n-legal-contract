{"version":3,"sources":["../../../../../nodes/vector_store/shared/MemoryManager/StoreCleanupService.ts"],"sourcesContent":["import type { MemoryVectorStore } from 'langchain/vectorstores/memory';\n\nimport type { VectorStoreMetadata, IStoreCleanupService } from './types';\n\n/**\n * Service for cleaning up vector stores based on inactivity or memory pressure\n */\nexport class StoreCleanupService implements IStoreCleanupService {\n\t// Cache for oldest stores sorted by creation time\n\tprivate oldestStoreKeys: string[] = [];\n\n\tprivate lastSortTime = 0;\n\n\tprivate readonly CACHE_TTL_MS = 5000; // 5 seconds\n\n\tconstructor(\n\t\tprivate readonly maxMemorySizeBytes: number,\n\t\tprivate readonly inactiveTtlMs: number,\n\t\tprivate readonly vectorStores: Map<string, MemoryVectorStore>,\n\t\tprivate readonly storeMetadata: Map<string, VectorStoreMetadata>,\n\t\tprivate readonly onCleanup: (\n\t\t\tremovedKeys: string[],\n\t\t\tfreedBytes: number,\n\t\t\treason: 'ttl' | 'memory',\n\t\t) => void,\n\t) {}\n\n\t/**\n\t * Check if a store has been inactive for longer than the TTL\n\t */\n\tisStoreInactive(metadata: VectorStoreMetadata): boolean {\n\t\t// If TTL is disabled, nothing is considered inactive\n\t\tif (this.inactiveTtlMs <= 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst now = Date.now();\n\t\tconst lastAccessedTime = metadata.lastAccessed.getTime();\n\t\treturn now - lastAccessedTime > this.inactiveTtlMs;\n\t}\n\n\t/**\n\t * Remove vector stores that haven't been accessed for longer than TTL\n\t */\n\tcleanupInactiveStores(): void {\n\t\t// Skip if TTL is disabled\n\t\tif (this.inactiveTtlMs <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet freedBytes = 0;\n\t\tconst removedStores: string[] = [];\n\n\t\t// Find and remove inactive stores\n\t\tfor (const [key, metadata] of this.storeMetadata.entries()) {\n\t\t\tif (this.isStoreInactive(metadata)) {\n\t\t\t\t// Remove this inactive store\n\t\t\t\tthis.vectorStores.delete(key);\n\t\t\t\tfreedBytes += metadata.size;\n\t\t\t\tremovedStores.push(key);\n\t\t\t}\n\t\t}\n\n\t\t// Remove from metadata after iteration to avoid concurrent modification\n\t\tfor (const key of removedStores) {\n\t\t\tthis.storeMetadata.delete(key);\n\t\t}\n\n\t\t// Invalidate cache if we removed any stores\n\t\tif (removedStores.length > 0) {\n\t\t\tthis.oldestStoreKeys = [];\n\t\t\tthis.onCleanup(removedStores, freedBytes, 'ttl');\n\t\t}\n\t}\n\n\t/**\n\t * Remove the oldest vector stores to free up memory\n\t */\n\tcleanupOldestStores(requiredBytes: number): void {\n\t\t// Skip if memory limit is disabled\n\t\tif (this.maxMemorySizeBytes <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate current total memory usage\n\t\tlet currentMemoryUsage = 0;\n\t\tfor (const metadata of this.storeMetadata.values()) {\n\t\t\tcurrentMemoryUsage += metadata.size;\n\t\t}\n\n\t\t// First, try to clean up inactive stores\n\t\tthis.cleanupInactiveStores();\n\n\t\t// Recalculate memory usage after inactive cleanup\n\t\tcurrentMemoryUsage = 0;\n\t\tfor (const metadata of this.storeMetadata.values()) {\n\t\t\tcurrentMemoryUsage += metadata.size;\n\t\t}\n\n\t\t// If no more cleanup needed, return early\n\t\tif (currentMemoryUsage + requiredBytes <= this.maxMemorySizeBytes) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst now = Date.now();\n\n\t\t// Reuse cached ordering if available and not stale\n\t\tif (this.oldestStoreKeys.length === 0 || now - this.lastSortTime > this.CACHE_TTL_MS) {\n\t\t\t// Collect and sort store keys by age\n\t\t\tconst stores: Array<[string, number]> = [];\n\n\t\t\tfor (const [key, metadata] of this.storeMetadata.entries()) {\n\t\t\t\tstores.push([key, metadata.createdAt.getTime()]);\n\t\t\t}\n\n\t\t\t// Sort by creation time (oldest first)\n\t\t\tstores.sort((a, b) => a[1] - b[1]);\n\n\t\t\t// Extract just the keys\n\t\t\tthis.oldestStoreKeys = stores.map(([key]) => key);\n\t\t\tthis.lastSortTime = now;\n\t\t}\n\n\t\tlet freedBytes = 0;\n\t\tconst removedStores: string[] = [];\n\n\t\t// Remove stores in order until we have enough space\n\t\tfor (const key of this.oldestStoreKeys) {\n\t\t\t// Skip if store no longer exists\n\t\t\tif (!this.storeMetadata.has(key)) continue;\n\n\t\t\t// Stop if we've freed enough space\n\t\t\tif (currentMemoryUsage - freedBytes + requiredBytes <= this.maxMemorySizeBytes) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst metadata = this.storeMetadata.get(key);\n\t\t\tif (metadata) {\n\t\t\t\tthis.vectorStores.delete(key);\n\t\t\t\tfreedBytes += metadata.size;\n\t\t\t\tremovedStores.push(key);\n\t\t\t}\n\t\t}\n\n\t\t// Remove from metadata after iteration to avoid concurrent modification\n\t\tfor (const key of removedStores) {\n\t\t\tthis.storeMetadata.delete(key);\n\t\t}\n\n\t\t// Update our cache if we removed stores\n\t\tif (removedStores.length > 0) {\n\t\t\t// Filter out removed stores from cached keys\n\t\t\tthis.oldestStoreKeys = this.oldestStoreKeys.filter((key) => !removedStores.includes(key));\n\t\t\tthis.onCleanup(removedStores, freedBytes, 'memory');\n\t\t}\n\t}\n}\n"],"mappings":"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","names":[]}