{"version":3,"sources":["../../../../../nodes/vector_store/shared/MemoryManager/MemoryVectorStoreManager.ts"],"sourcesContent":["import type { Document } from '@langchain/core/documents';\nimport type { Embeddings } from '@langchain/core/embeddings';\nimport { MemoryVectorStore } from 'langchain/vectorstores/memory';\nimport type { Logger } from 'n8n-workflow';\n\nimport { getConfig, mbToBytes, hoursToMs } from './config';\nimport { MemoryCalculator } from './MemoryCalculator';\nimport { StoreCleanupService } from './StoreCleanupService';\nimport type { VectorStoreMetadata, VectorStoreStats } from './types';\n\n/**\n * Manages in-memory vector stores with memory limits and auto-cleanup\n */\nexport class MemoryVectorStoreManager {\n\tprivate static instance: MemoryVectorStoreManager | null = null;\n\n\t// Storage\n\tprotected vectorStoreBuffer: Map<string, MemoryVectorStore>;\n\n\tprotected storeMetadata: Map<string, VectorStoreMetadata>;\n\n\tprotected memoryUsageBytes: number = 0;\n\n\t// Dependencies\n\tprotected memoryCalculator: MemoryCalculator;\n\n\tprotected cleanupService: StoreCleanupService;\n\n\tprotected static logger: Logger;\n\n\t// Config values\n\tprotected maxMemorySizeBytes: number;\n\n\tprotected inactiveTtlMs: number;\n\n\t// Inactive TTL cleanup timer\n\tprotected ttlCleanupIntervalId: NodeJS.Timeout | null = null;\n\n\tprotected constructor(\n\t\tprotected embeddings: Embeddings,\n\t\tprotected logger: Logger,\n\t) {\n\t\t// Initialize storage\n\t\tthis.vectorStoreBuffer = new Map();\n\t\tthis.storeMetadata = new Map();\n\t\tthis.logger = logger;\n\n\t\tconst config = getConfig();\n\t\tthis.maxMemorySizeBytes = mbToBytes(config.maxMemoryMB);\n\t\tthis.inactiveTtlMs = hoursToMs(config.ttlHours);\n\n\t\t// Initialize services\n\t\tthis.memoryCalculator = new MemoryCalculator();\n\t\tthis.cleanupService = new StoreCleanupService(\n\t\t\tthis.maxMemorySizeBytes,\n\t\t\tthis.inactiveTtlMs,\n\t\t\tthis.vectorStoreBuffer,\n\t\t\tthis.storeMetadata,\n\t\t\tthis.handleCleanup.bind(this),\n\t\t);\n\n\t\tthis.setupTtlCleanup();\n\t}\n\n\t/**\n\t * Get singleton instance\n\t */\n\tstatic getInstance(embeddings: Embeddings, logger: Logger): MemoryVectorStoreManager {\n\t\tif (!MemoryVectorStoreManager.instance) {\n\t\t\tMemoryVectorStoreManager.instance = new MemoryVectorStoreManager(embeddings, logger);\n\t\t} else {\n\t\t\t// We need to update the embeddings in the existing instance.\n\t\t\t// This is important as embeddings instance is wrapped in a logWrapper,\n\t\t\t// which relies on supplyDataFunctions context which changes on each workflow run\n\t\t\tMemoryVectorStoreManager.instance.embeddings = embeddings;\n\t\t\tMemoryVectorStoreManager.instance.vectorStoreBuffer.forEach((vectorStoreInstance) => {\n\t\t\t\tvectorStoreInstance.embeddings = embeddings;\n\t\t\t});\n\t\t}\n\n\t\treturn MemoryVectorStoreManager.instance;\n\t}\n\n\t/**\n\t * Set up timer for TTL-based cleanup\n\t */\n\tprivate setupTtlCleanup(): void {\n\t\t// Skip setup if TTL is disabled\n\t\tif (this.inactiveTtlMs <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Cleanup check interval (run every hour)\n\t\tconst CLEANUP_INTERVAL_MS = 60 * 60 * 1000;\n\n\t\t// Clear any existing interval\n\t\tif (this.ttlCleanupIntervalId) {\n\t\t\tclearInterval(this.ttlCleanupIntervalId);\n\t\t}\n\n\t\t// Setup new interval for TTL cleanup\n\t\tthis.ttlCleanupIntervalId = setInterval(() => {\n\t\t\tthis.cleanupService.cleanupInactiveStores();\n\t\t}, CLEANUP_INTERVAL_MS);\n\t}\n\n\t/**\n\t * Handle cleanup events from the cleanup service\n\t */\n\tprivate handleCleanup(removedKeys: string[], freedBytes: number, reason: 'ttl' | 'memory'): void {\n\t\t// Update total memory usage\n\t\tthis.memoryUsageBytes -= freedBytes;\n\n\t\t// Log cleanup event\n\t\tif (reason === 'ttl') {\n\t\t\tconst ttlHours = Math.round(this.inactiveTtlMs / (60 * 60 * 1000));\n\t\t\tthis.logger.info(\n\t\t\t\t`TTL cleanup: removed ${removedKeys.length} inactive vector stores (${ttlHours}h TTL) to free ${Math.round(freedBytes / (1024 * 1024))}MB of memory`,\n\t\t\t);\n\t\t} else {\n\t\t\tthis.logger.info(\n\t\t\t\t`Memory cleanup: removed ${removedKeys.length} oldest vector stores to free ${Math.round(freedBytes / (1024 * 1024))}MB of memory`,\n\t\t\t);\n\t\t}\n\t}\n\n\tgetMemoryKeysList(): string[] {\n\t\treturn Array.from(this.vectorStoreBuffer.keys());\n\t}\n\n\t/**\n\t * Get or create a vector store by key\n\t */\n\tasync getVectorStore(memoryKey: string): Promise<MemoryVectorStore> {\n\t\tlet vectorStoreInstance = this.vectorStoreBuffer.get(memoryKey);\n\n\t\tif (!vectorStoreInstance) {\n\t\t\tvectorStoreInstance = await MemoryVectorStore.fromExistingIndex(this.embeddings);\n\t\t\tthis.vectorStoreBuffer.set(memoryKey, vectorStoreInstance);\n\n\t\t\tthis.storeMetadata.set(memoryKey, {\n\t\t\t\tsize: 0,\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tlastAccessed: new Date(),\n\t\t\t});\n\t\t} else {\n\t\t\tconst metadata = this.storeMetadata.get(memoryKey);\n\t\t\tif (metadata) {\n\t\t\t\tmetadata.lastAccessed = new Date();\n\t\t\t}\n\t\t}\n\n\t\treturn vectorStoreInstance;\n\t}\n\n\t/**\n\t * Reset a store's metadata when it's cleared\n\t */\n\tprotected clearStoreMetadata(memoryKey: string): void {\n\t\tconst metadata = this.storeMetadata.get(memoryKey);\n\t\tif (metadata) {\n\t\t\tthis.memoryUsageBytes -= metadata.size;\n\t\t\tmetadata.size = 0;\n\t\t\tmetadata.lastAccessed = new Date();\n\t\t}\n\t}\n\n\t/**\n\t * Get memory usage in bytes\n\t */\n\tgetMemoryUsage(): number {\n\t\treturn this.memoryUsageBytes;\n\t}\n\n\t/**\n\t * Get memory usage as a formatted string (MB)\n\t */\n\tgetMemoryUsageFormatted(): string {\n\t\treturn `${Math.round(this.memoryUsageBytes / (1024 * 1024))}MB`;\n\t}\n\n\t/**\n\t * Recalculate memory usage from actual vector store contents\n\t * This ensures tracking accuracy for large stores\n\t */\n\trecalculateMemoryUsage(): void {\n\t\tthis.memoryUsageBytes = 0;\n\n\t\t// Recalculate for each store\n\t\tfor (const [key, vectorStore] of this.vectorStoreBuffer.entries()) {\n\t\t\tconst storeSize = this.memoryCalculator.calculateVectorStoreSize(vectorStore);\n\n\t\t\t// Update metadata\n\t\t\tconst metadata = this.storeMetadata.get(key);\n\t\t\tif (metadata) {\n\t\t\t\tmetadata.size = storeSize;\n\t\t\t\tthis.memoryUsageBytes += storeSize;\n\t\t\t}\n\t\t}\n\n\t\tthis.logger.debug(`Recalculated vector store memory: ${this.getMemoryUsageFormatted()}`);\n\t}\n\n\t/**\n\t * Add documents to a vector store\n\t */\n\tasync addDocuments(\n\t\tmemoryKey: string,\n\t\tdocuments: Document[],\n\t\tclearStore?: boolean,\n\t): Promise<void> {\n\t\tif (clearStore) {\n\t\t\tthis.clearStoreMetadata(memoryKey);\n\t\t\tthis.vectorStoreBuffer.delete(memoryKey);\n\t\t}\n\n\t\t// Fast batch estimation instead of per-document calculation\n\t\tconst estimatedAddedSize = this.memoryCalculator.estimateBatchSize(documents);\n\n\t\t// Clean up old stores if necessary\n\t\tthis.cleanupService.cleanupOldestStores(estimatedAddedSize);\n\n\t\tconst vectorStoreInstance = await this.getVectorStore(memoryKey);\n\n\t\t// Get vector count before adding documents\n\t\tconst vectorCountBefore = vectorStoreInstance.memoryVectors?.length || 0;\n\n\t\tawait vectorStoreInstance.addDocuments(documents);\n\n\t\t// Update store metadata and memory tracking\n\t\tconst metadata = this.storeMetadata.get(memoryKey);\n\t\tif (metadata) {\n\t\t\tmetadata.size += estimatedAddedSize;\n\t\t\tmetadata.lastAccessed = new Date();\n\t\t\tthis.memoryUsageBytes += estimatedAddedSize;\n\t\t}\n\n\t\t// Get updated vector count\n\t\tconst vectorCount = vectorStoreInstance.memoryVectors?.length || 0;\n\n\t\t// Periodically recalculate actual memory usage to avoid drift\n\t\tif (\n\t\t\t(vectorCount > 0 && vectorCount % 100 === 0) ||\n\t\t\tdocuments.length > 20 ||\n\t\t\t(vectorCountBefore === 0 && vectorCount > 0)\n\t\t) {\n\t\t\tthis.recalculateMemoryUsage();\n\t\t}\n\n\t\t// Logging memory usage\n\t\tconst maxMemoryMB =\n\t\t\tthis.maxMemorySizeBytes > 0\n\t\t\t\t? (this.maxMemorySizeBytes / (1024 * 1024)).toFixed(0)\n\t\t\t\t: 'unlimited';\n\n\t\tthis.logger.debug(\n\t\t\t`Vector store memory: ${this.getMemoryUsageFormatted()}/${maxMemoryMB}MB (${vectorCount} vectors in ${this.vectorStoreBuffer.size} stores)`,\n\t\t);\n\t}\n\n\t/**\n\t * Get statistics about the vector store memory usage\n\t */\n\tgetStats(): VectorStoreStats {\n\t\tconst now = Date.now();\n\t\tlet inactiveStoreCount = 0;\n\n\t\t// Always recalculate when getting stats to ensure accuracy\n\t\tthis.recalculateMemoryUsage();\n\n\t\tconst stats: VectorStoreStats = {\n\t\t\ttotalSizeBytes: this.memoryUsageBytes,\n\t\t\ttotalSizeMB: Math.round((this.memoryUsageBytes / (1024 * 1024)) * 100) / 100,\n\t\t\tpercentOfLimit:\n\t\t\t\tthis.maxMemorySizeBytes > 0\n\t\t\t\t\t? Math.round((this.memoryUsageBytes / this.maxMemorySizeBytes) * 100)\n\t\t\t\t\t: 0,\n\t\t\tmaxMemoryMB: this.maxMemorySizeBytes > 0 ? this.maxMemorySizeBytes / (1024 * 1024) : -1, // -1 indicates unlimited\n\t\t\tstoreCount: this.vectorStoreBuffer.size,\n\t\t\tinactiveStoreCount: 0,\n\t\t\tttlHours: this.inactiveTtlMs > 0 ? this.inactiveTtlMs / (60 * 60 * 1000) : -1, // -1 indicates disabled\n\t\t\tstores: {},\n\t\t};\n\n\t\t// Add stats for each store\n\t\tfor (const [key, metadata] of this.storeMetadata.entries()) {\n\t\t\tconst store = this.vectorStoreBuffer.get(key);\n\n\t\t\tif (store) {\n\t\t\t\tconst lastAccessedTime = metadata.lastAccessed.getTime();\n\t\t\t\tconst inactiveTimeMs = now - lastAccessedTime;\n\t\t\t\tconst isInactive = this.cleanupService.isStoreInactive(metadata);\n\n\t\t\t\tif (isInactive) {\n\t\t\t\t\tinactiveStoreCount++;\n\t\t\t\t}\n\n\t\t\t\tstats.stores[key] = {\n\t\t\t\t\tsizeBytes: metadata.size,\n\t\t\t\t\tsizeMB: Math.round((metadata.size / (1024 * 1024)) * 100) / 100,\n\t\t\t\t\tpercentOfTotal: Math.round((metadata.size / this.memoryUsageBytes) * 100) || 0,\n\t\t\t\t\tvectors: store.memoryVectors?.length || 0,\n\t\t\t\t\tcreatedAt: metadata.createdAt.toISOString(),\n\t\t\t\t\tlastAccessed: metadata.lastAccessed.toISOString(),\n\t\t\t\t\tinactive: isInactive,\n\t\t\t\t\tinactiveForHours: Math.round(inactiveTimeMs / (60 * 60 * 1000)),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tstats.inactiveStoreCount = inactiveStoreCount;\n\n\t\treturn stats;\n\t}\n}\n"],"mappings":"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","names":[]}