{"version":3,"sources":["../../../../../../nodes/vector_store/shared/createVectorStoreNode/operations/updateOperation.ts"],"sourcesContent":["import type { Embeddings } from '@langchain/core/embeddings';\nimport type { VectorStore } from '@langchain/core/vectorstores';\nimport type { IExecuteFunctions, INodeExecutionData } from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport { logAiEvent } from '@utils/helpers';\nimport { N8nJsonLoader } from '@utils/N8nJsonLoader';\n\nimport { processDocument } from '../../processDocuments';\nimport type { VectorStoreNodeConstructorArgs } from '../types';\nimport { isUpdateSupported } from '../utils';\n\n/**\n * Handles the 'update' operation mode\n * Updates existing documents in the vector store by ID\n */\nexport async function handleUpdateOperation<T extends VectorStore = VectorStore>(\n\tcontext: IExecuteFunctions,\n\targs: VectorStoreNodeConstructorArgs<T>,\n\tembeddings: Embeddings,\n): Promise<INodeExecutionData[]> {\n\t// First check if update operation is supported by this vector store\n\tif (!isUpdateSupported(args)) {\n\t\tthrow new NodeOperationError(\n\t\t\tcontext.getNode(),\n\t\t\t'Update operation is not implemented for this Vector Store',\n\t\t);\n\t}\n\n\t// Get input items\n\tconst items = context.getInputData();\n\t// Create a loader for processing document data\n\tconst loader = new N8nJsonLoader(context);\n\n\tconst resultData: INodeExecutionData[] = [];\n\n\t// Process each input item\n\tfor (let itemIndex = 0; itemIndex < items.length; itemIndex++) {\n\t\tconst itemData = items[itemIndex];\n\n\t\t// Get the document ID to update\n\t\tconst documentId = context.getNodeParameter('id', itemIndex, '', {\n\t\t\textractValue: true,\n\t\t}) as string;\n\n\t\t// Get the vector store client\n\t\tconst vectorStore = await args.getVectorStoreClient(context, undefined, embeddings, itemIndex);\n\n\t\ttry {\n\t\t\t// Process the document from the input\n\t\t\tconst { processedDocuments, serializedDocuments } = await processDocument(\n\t\t\t\tloader,\n\t\t\t\titemData,\n\t\t\t\titemIndex,\n\t\t\t);\n\n\t\t\t// Validate that we have exactly one document to update\n\t\t\tif (processedDocuments?.length !== 1) {\n\t\t\t\tthrow new NodeOperationError(context.getNode(), 'Single document per item expected');\n\t\t\t}\n\n\t\t\t// Add the serialized document to the result\n\t\t\tresultData.push(...serializedDocuments);\n\n\t\t\t// Use document ID to update the existing document\n\t\t\tawait vectorStore.addDocuments(processedDocuments, {\n\t\t\t\tids: [documentId],\n\t\t\t});\n\n\t\t\t// Log the AI event for analytics\n\t\t\tlogAiEvent(context, 'ai-vector-store-updated');\n\t\t} finally {\n\t\t\t// Release the vector store client if a release method was provided\n\t\t\targs.releaseVectorStoreClient?.(vectorStore);\n\t\t}\n\t}\n\n\treturn resultData;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,0BAAmC;AAEnC,qBAA2B;AAC3B,2BAA8B;AAE9B,8BAAgC;AAEhC,mBAAkC;AAMlC,eAAsB,sBACrB,SACA,MACA,YACgC;AAEhC,MAAI,KAAC,gCAAkB,IAAI,GAAG;AAC7B,UAAM,IAAI;AAAA,MACT,QAAQ,QAAQ;AAAA,MAChB;AAAA,IACD;AAAA,EACD;AAGA,QAAM,QAAQ,QAAQ,aAAa;AAEnC,QAAM,SAAS,IAAI,mCAAc,OAAO;AAExC,QAAM,aAAmC,CAAC;AAG1C,WAAS,YAAY,GAAG,YAAY,MAAM,QAAQ,aAAa;AAC9D,UAAM,WAAW,MAAM,SAAS;AAGhC,UAAM,aAAa,QAAQ,iBAAiB,MAAM,WAAW,IAAI;AAAA,MAChE,cAAc;AAAA,IACf,CAAC;AAGD,UAAM,cAAc,MAAM,KAAK,qBAAqB,SAAS,QAAW,YAAY,SAAS;AAE7F,QAAI;AAEH,YAAM,EAAE,oBAAoB,oBAAoB,IAAI,UAAM;AAAA,QACzD;AAAA,QACA;AAAA,QACA;AAAA,MACD;AAGA,UAAI,oBAAoB,WAAW,GAAG;AACrC,cAAM,IAAI,uCAAmB,QAAQ,QAAQ,GAAG,mCAAmC;AAAA,MACpF;AAGA,iBAAW,KAAK,GAAG,mBAAmB;AAGtC,YAAM,YAAY,aAAa,oBAAoB;AAAA,QAClD,KAAK,CAAC,UAAU;AAAA,MACjB,CAAC;AAGD,qCAAW,SAAS,yBAAyB;AAAA,IAC9C,UAAE;AAED,WAAK,2BAA2B,WAAW;AAAA,IAC5C;AAAA,EACD;AAEA,SAAO;AACR;","names":[]}