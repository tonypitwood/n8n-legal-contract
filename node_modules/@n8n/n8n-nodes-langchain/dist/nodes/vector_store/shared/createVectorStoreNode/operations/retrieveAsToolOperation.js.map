{"version":3,"sources":["../../../../../../nodes/vector_store/shared/createVectorStoreNode/operations/retrieveAsToolOperation.ts"],"sourcesContent":["import type { Embeddings } from '@langchain/core/embeddings';\nimport type { BaseDocumentCompressor } from '@langchain/core/retrievers/document_compressors';\nimport type { VectorStore } from '@langchain/core/vectorstores';\nimport { DynamicTool } from 'langchain/tools';\nimport { NodeConnectionTypes, type ISupplyDataFunctions, type SupplyData } from 'n8n-workflow';\n\nimport { getMetadataFiltersValues } from '@utils/helpers';\nimport { nodeNameToToolName } from 'n8n-workflow';\nimport { logWrapper } from '@utils/logWrapper';\n\nimport type { VectorStoreNodeConstructorArgs } from '../types';\n\n/**\n * Handles the 'retrieve-as-tool' operation mode\n * Returns a tool that can be used with AI Agent nodes\n */\nexport async function handleRetrieveAsToolOperation<T extends VectorStore = VectorStore>(\n\tcontext: ISupplyDataFunctions,\n\targs: VectorStoreNodeConstructorArgs<T>,\n\tembeddings: Embeddings,\n\titemIndex: number,\n): Promise<SupplyData> {\n\t// Get the tool configuration parameters\n\tconst toolDescription = context.getNodeParameter('toolDescription', itemIndex) as string;\n\n\tconst node = context.getNode();\n\tconst { typeVersion } = node;\n\tconst toolName =\n\t\ttypeVersion < 1.3\n\t\t\t? (context.getNodeParameter('toolName', itemIndex) as string)\n\t\t\t: nodeNameToToolName(node);\n\n\tconst topK = context.getNodeParameter('topK', itemIndex, 4) as number;\n\tconst useReranker = context.getNodeParameter('useReranker', itemIndex, false) as boolean;\n\tconst includeDocumentMetadata = context.getNodeParameter(\n\t\t'includeDocumentMetadata',\n\t\titemIndex,\n\t\ttrue,\n\t) as boolean;\n\n\t// Get metadata filters\n\tconst filter = getMetadataFiltersValues(context, itemIndex);\n\n\t// Create a Dynamic Tool that wraps vector store search functionality\n\tconst vectorStoreTool = new DynamicTool({\n\t\tname: toolName,\n\t\tdescription: toolDescription,\n\t\tfunc: async (input) => {\n\t\t\t// For each tool use, get a fresh vector store client.\n\t\t\t// We don't pass in a filter here only later in the similaritySearchVectorWithScore\n\t\t\t// method to avoid an exception with some vector stores like Supabase or Pinecone(#AI-740)\n\t\t\tconst vectorStore = await args.getVectorStoreClient(\n\t\t\t\tcontext,\n\t\t\t\tundefined,\n\t\t\t\tembeddings,\n\t\t\t\titemIndex,\n\t\t\t);\n\n\t\t\ttry {\n\t\t\t\t// Embed the input query\n\t\t\t\tconst embeddedPrompt = await embeddings.embedQuery(input);\n\n\t\t\t\t// Search for similar documents\n\t\t\t\tlet documents = await vectorStore.similaritySearchVectorWithScore(\n\t\t\t\t\tembeddedPrompt,\n\t\t\t\t\ttopK,\n\t\t\t\t\tfilter,\n\t\t\t\t);\n\n\t\t\t\t// If reranker is used, rerank the documents\n\t\t\t\tif (useReranker && documents.length > 0) {\n\t\t\t\t\tconst reranker = (await context.getInputConnectionData(\n\t\t\t\t\t\tNodeConnectionTypes.AiReranker,\n\t\t\t\t\t\t0,\n\t\t\t\t\t)) as BaseDocumentCompressor;\n\n\t\t\t\t\tconst docs = documents.map(([doc]) => doc);\n\t\t\t\t\tconst rerankedDocuments = await reranker.compressDocuments(docs, input);\n\t\t\t\t\tdocuments = rerankedDocuments.map((doc) => {\n\t\t\t\t\t\tconst { relevanceScore, ...metadata } = doc.metadata;\n\t\t\t\t\t\treturn [{ ...doc, metadata }, relevanceScore];\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Format the documents for the tool output\n\t\t\t\treturn documents\n\t\t\t\t\t.map((document) => {\n\t\t\t\t\t\tif (includeDocumentMetadata) {\n\t\t\t\t\t\t\treturn { type: 'text', text: JSON.stringify(document[0]) };\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\t\ttext: JSON.stringify({ pageContent: document[0].pageContent }),\n\t\t\t\t\t\t};\n\t\t\t\t\t})\n\t\t\t\t\t.filter((document) => !!document);\n\t\t\t} finally {\n\t\t\t\t// Release the vector store client if a release method was provided\n\t\t\t\targs.releaseVectorStoreClient?.(vectorStore);\n\t\t\t}\n\t\t},\n\t});\n\n\t// Return the vector store tool with logging wrapper\n\treturn {\n\t\tresponse: logWrapper(vectorStoreTool, context),\n\t};\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,mBAA4B;AAC5B,0BAAgF;AAEhF,qBAAyC;AACzC,IAAAA,uBAAmC;AACnC,wBAA2B;AAQ3B,eAAsB,8BACrB,SACA,MACA,YACA,WACsB;AAEtB,QAAM,kBAAkB,QAAQ,iBAAiB,mBAAmB,SAAS;AAE7E,QAAM,OAAO,QAAQ,QAAQ;AAC7B,QAAM,EAAE,YAAY,IAAI;AACxB,QAAM,WACL,cAAc,MACV,QAAQ,iBAAiB,YAAY,SAAS,QAC/C,yCAAmB,IAAI;AAE3B,QAAM,OAAO,QAAQ,iBAAiB,QAAQ,WAAW,CAAC;AAC1D,QAAM,cAAc,QAAQ,iBAAiB,eAAe,WAAW,KAAK;AAC5E,QAAM,0BAA0B,QAAQ;AAAA,IACvC;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAGA,QAAM,aAAS,yCAAyB,SAAS,SAAS;AAG1D,QAAM,kBAAkB,IAAI,yBAAY;AAAA,IACvC,MAAM;AAAA,IACN,aAAa;AAAA,IACb,MAAM,OAAO,UAAU;AAItB,YAAM,cAAc,MAAM,KAAK;AAAA,QAC9B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACD;AAEA,UAAI;AAEH,cAAM,iBAAiB,MAAM,WAAW,WAAW,KAAK;AAGxD,YAAI,YAAY,MAAM,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAGA,YAAI,eAAe,UAAU,SAAS,GAAG;AACxC,gBAAM,WAAY,MAAM,QAAQ;AAAA,YAC/B,wCAAoB;AAAA,YACpB;AAAA,UACD;AAEA,gBAAM,OAAO,UAAU,IAAI,CAAC,CAAC,GAAG,MAAM,GAAG;AACzC,gBAAM,oBAAoB,MAAM,SAAS,kBAAkB,MAAM,KAAK;AACtE,sBAAY,kBAAkB,IAAI,CAAC,QAAQ;AAC1C,kBAAM,EAAE,gBAAgB,GAAG,SAAS,IAAI,IAAI;AAC5C,mBAAO,CAAC,EAAE,GAAG,KAAK,SAAS,GAAG,cAAc;AAAA,UAC7C,CAAC;AAAA,QACF;AAGA,eAAO,UACL,IAAI,CAAC,aAAa;AAClB,cAAI,yBAAyB;AAC5B,mBAAO,EAAE,MAAM,QAAQ,MAAM,KAAK,UAAU,SAAS,CAAC,CAAC,EAAE;AAAA,UAC1D;AACA,iBAAO;AAAA,YACN,MAAM;AAAA,YACN,MAAM,KAAK,UAAU,EAAE,aAAa,SAAS,CAAC,EAAE,YAAY,CAAC;AAAA,UAC9D;AAAA,QACD,CAAC,EACA,OAAO,CAAC,aAAa,CAAC,CAAC,QAAQ;AAAA,MAClC,UAAE;AAED,aAAK,2BAA2B,WAAW;AAAA,MAC5C;AAAA,IACD;AAAA,EACD,CAAC;AAGD,SAAO;AAAA,IACN,cAAU,8BAAW,iBAAiB,OAAO;AAAA,EAC9C;AACD;","names":["import_n8n_workflow"]}