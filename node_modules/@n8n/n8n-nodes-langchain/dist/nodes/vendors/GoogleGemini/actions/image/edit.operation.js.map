{"version":3,"sources":["../../../../../../nodes/vendors/GoogleGemini/actions/image/edit.operation.ts"],"sourcesContent":["import type { IExecuteFunctions, INodeExecutionData, INodeProperties } from 'n8n-workflow';\nimport { updateDisplayOptions } from 'n8n-workflow';\n\nimport type { GenerateContentResponse } from '../../helpers/interfaces';\nimport { uploadFile } from '../../helpers/utils';\nimport { apiRequest } from '../../transport';\n\ninterface ImagesParameter {\n\tvalues?: Array<{ binaryPropertyName?: string }>;\n}\n\nfunction isImagesParameter(param: unknown): param is ImagesParameter {\n\tif (typeof param !== 'object' || param === null) {\n\t\treturn false;\n\t}\n\n\tconst paramObj = param as Record<string, unknown>;\n\n\tif (!('values' in paramObj)) {\n\t\treturn true; // values is optional\n\t}\n\n\tif (!Array.isArray(paramObj.values)) {\n\t\treturn false;\n\t}\n\n\treturn paramObj.values.every((item: unknown) => {\n\t\tif (typeof item !== 'object' || item === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst itemObj = item as Record<string, unknown>;\n\n\t\tif (!('binaryPropertyName' in itemObj)) {\n\t\t\treturn true; // binaryPropertyName is optional\n\t\t}\n\n\t\treturn (\n\t\t\ttypeof itemObj.binaryPropertyName === 'string' || itemObj.binaryPropertyName === undefined\n\t\t);\n\t});\n}\n\nfunction isGenerateContentResponse(response: unknown): response is GenerateContentResponse {\n\tif (typeof response !== 'object' || response === null) {\n\t\treturn false;\n\t}\n\n\tconst responseObj = response as Record<string, unknown>;\n\n\tif (!('candidates' in responseObj) || !Array.isArray(responseObj.candidates)) {\n\t\treturn false;\n\t}\n\n\treturn responseObj.candidates.every((candidate: unknown) => {\n\t\tif (typeof candidate !== 'object' || candidate === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst candidateObj = candidate as Record<string, unknown>;\n\n\t\tif (\n\t\t\t!('content' in candidateObj) ||\n\t\t\ttypeof candidateObj.content !== 'object' ||\n\t\t\tcandidateObj.content === null\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst contentObj = candidateObj.content as Record<string, unknown>;\n\n\t\treturn 'parts' in contentObj && Array.isArray(contentObj.parts);\n\t});\n}\n\nconst properties: INodeProperties[] = [\n\t{\n\t\tdisplayName: 'Prompt',\n\t\tname: 'prompt',\n\t\ttype: 'string',\n\t\tplaceholder: 'e.g. combine the first image with the second image',\n\t\tdescription: 'Instruction describing how to edit the image',\n\t\tdefault: '',\n\t\ttypeOptions: {\n\t\t\trows: 2,\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Images',\n\t\tname: 'images',\n\t\ttype: 'fixedCollection',\n\t\tplaceholder: 'Add Image',\n\t\ttypeOptions: {\n\t\t\tmultipleValues: true,\n\t\t\tmultipleValueButtonText: 'Add Image',\n\t\t},\n\t\tdefault: { values: [{ binaryPropertyName: 'data' }] },\n\t\tdescription: 'Add one or more binary fields to include images with your prompt',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Image',\n\t\t\t\tname: 'values',\n\t\t\t\tvalues: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Binary Field Name',\n\t\t\t\t\t\tname: 'binaryPropertyName',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdefault: 'data',\n\t\t\t\t\t\tplaceholder: 'e.g. data',\n\t\t\t\t\t\tdescription: 'The name of the binary field containing the image data',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\tplaceholder: 'Add Option',\n\t\ttype: 'collection',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Put Output in Field',\n\t\t\t\tname: 'binaryPropertyOutput',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: 'edited',\n\t\t\t\thint: 'The name of the output field to put the binary file data in',\n\t\t\t},\n\t\t],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\toperation: ['edit'],\n\t\tresource: ['image'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(this: IExecuteFunctions, i: number): Promise<INodeExecutionData[]> {\n\tconst prompt = this.getNodeParameter('prompt', i, '');\n\tconst binaryPropertyOutput = this.getNodeParameter('options.binaryPropertyOutput', i, 'edited');\n\tconst outputKey = typeof binaryPropertyOutput === 'string' ? binaryPropertyOutput : 'data';\n\n\t// Collect image binary field names from collection\n\tconst imagesParam = this.getNodeParameter('images', i, {\n\t\tvalues: [{ binaryPropertyName: 'data' }],\n\t});\n\n\tif (!isImagesParameter(imagesParam)) {\n\t\tthrow new Error('Invalid images parameter format');\n\t}\n\n\tconst imagesUi = imagesParam.values ?? [];\n\tconst imageFieldNames = imagesUi\n\t\t.map((v) => v.binaryPropertyName)\n\t\t.filter((n): n is string => Boolean(n));\n\n\t// Upload all images and gather fileData parts\n\tconst fileParts = [] as Array<{ fileData: { fileUri: string; mimeType: string } }>;\n\tfor (const fieldName of imageFieldNames) {\n\t\tconst bin = this.helpers.assertBinaryData(i, fieldName);\n\t\tconst buf = await this.helpers.getBinaryDataBuffer(i, fieldName);\n\t\tconst uploaded = await uploadFile.call(this, buf, bin.mimeType);\n\t\tfileParts.push({ fileData: { fileUri: uploaded.fileUri, mimeType: uploaded.mimeType } });\n\t}\n\n\tconst model = 'models/gemini-2.5-flash-image-preview';\n\tconst generationConfig = {\n\t\tresponseModalities: ['IMAGE'],\n\t};\n\n\tconst body = {\n\t\tcontents: [\n\t\t\t{\n\t\t\t\trole: 'user',\n\t\t\t\tparts: [...fileParts, { text: prompt }],\n\t\t\t},\n\t\t],\n\t\tgenerationConfig,\n\t};\n\n\tconst response: unknown = await apiRequest.call(\n\t\tthis,\n\t\t'POST',\n\t\t`/v1beta/${model}:generateContent`,\n\t\t{\n\t\t\tbody,\n\t\t},\n\t);\n\n\tif (!isGenerateContentResponse(response)) {\n\t\tthrow new Error('Invalid response format from Gemini API');\n\t}\n\n\tconst promises = response.candidates.map(async (candidate) => {\n\t\tconst imagePart = candidate.content.parts.find((part) => 'inlineData' in part);\n\n\t\t// Check if imagePart exists and has inlineData with actual data\n\t\tif (!imagePart?.inlineData?.data) {\n\t\t\tthrow new Error('No image data returned from Gemini API');\n\t\t}\n\n\t\tconst bufferOut = Buffer.from(imagePart.inlineData.data, 'base64');\n\t\tconst binaryOut = await this.helpers.prepareBinaryData(\n\t\t\tbufferOut,\n\t\t\t'image.png',\n\t\t\timagePart.inlineData.mimeType,\n\t\t);\n\t\treturn {\n\t\t\tbinary: {\n\t\t\t\t[outputKey]: binaryOut,\n\t\t\t},\n\t\t\tjson: {\n\t\t\t\t...binaryOut,\n\t\t\t\tdata: undefined,\n\t\t\t},\n\t\t\tpairedItem: { item: i },\n\t\t};\n\t});\n\n\treturn await Promise.all(promises);\n}\n"],"mappings":"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","names":[]}