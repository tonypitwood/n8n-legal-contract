{"version":3,"sources":["../../../../../../nodes/vendors/GoogleGemini/actions/image/generate.operation.ts"],"sourcesContent":["import type { IExecuteFunctions, INodeExecutionData, INodeProperties } from 'n8n-workflow';\nimport { NodeOperationError, updateDisplayOptions } from 'n8n-workflow';\n\nimport {\n\ttype GenerateContentRequest,\n\ttype GenerateContentResponse,\n\ttype ImagenResponse,\n\tModality,\n} from '../../helpers/interfaces';\nimport { apiRequest } from '../../transport';\nimport { modelRLC } from '../descriptions';\n\nconst properties: INodeProperties[] = [\n\tmodelRLC('imageGenerationModelSearch'),\n\t{\n\t\tdisplayName: 'Prompt',\n\t\tname: 'prompt',\n\t\ttype: 'string',\n\t\tplaceholder: 'e.g. A cute cat eating a dinosaur',\n\t\tdescription: 'A text description of the desired image(s)',\n\t\tdefault: '',\n\t\ttypeOptions: {\n\t\t\trows: 2,\n\t\t},\n\t},\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\tplaceholder: 'Add Option',\n\t\ttype: 'collection',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Number of Images',\n\t\t\t\tname: 'sampleCount',\n\t\t\t\tdefault: 1,\n\t\t\t\tdescription:\n\t\t\t\t\t'Number of images to generate. Not supported by Gemini models, supported by Imagen models.',\n\t\t\t\ttype: 'number',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Put Output in Field',\n\t\t\t\tname: 'binaryPropertyOutput',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: 'data',\n\t\t\t\thint: 'The name of the output field to put the binary file data in',\n\t\t\t},\n\t\t],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\toperation: ['generate'],\n\t\tresource: ['image'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(this: IExecuteFunctions, i: number): Promise<INodeExecutionData[]> {\n\tconst model = this.getNodeParameter('modelId', i, '', { extractValue: true }) as string;\n\tconst prompt = this.getNodeParameter('prompt', i, '') as string;\n\tconst binaryPropertyOutput = this.getNodeParameter(\n\t\t'options.binaryPropertyOutput',\n\t\ti,\n\t\t'data',\n\t) as string;\n\n\tif (model.includes('gemini')) {\n\t\tconst generationConfig = {\n\t\t\tresponseModalities: [Modality.IMAGE, Modality.TEXT],\n\t\t};\n\t\tconst body: GenerateContentRequest = {\n\t\t\tcontents: [\n\t\t\t\t{\n\t\t\t\t\trole: 'user',\n\t\t\t\t\tparts: [{ text: prompt }],\n\t\t\t\t},\n\t\t\t],\n\t\t\tgenerationConfig,\n\t\t};\n\n\t\tconst response = (await apiRequest.call(this, 'POST', `/v1beta/${model}:generateContent`, {\n\t\t\tbody,\n\t\t})) as GenerateContentResponse;\n\t\tconst promises = response.candidates.map(async (candidate) => {\n\t\t\tconst imagePart = candidate.content.parts.find((part) => 'inlineData' in part);\n\t\t\tconst buffer = Buffer.from(imagePart?.inlineData.data ?? '', 'base64');\n\t\t\tconst binaryData = await this.helpers.prepareBinaryData(\n\t\t\t\tbuffer,\n\t\t\t\t'image.png',\n\t\t\t\timagePart?.inlineData.mimeType,\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tbinary: {\n\t\t\t\t\t[binaryPropertyOutput]: binaryData,\n\t\t\t\t},\n\t\t\t\tjson: {\n\t\t\t\t\t...binaryData,\n\t\t\t\t\tdata: undefined,\n\t\t\t\t},\n\t\t\t\tpairedItem: { item: i },\n\t\t\t};\n\t\t});\n\n\t\treturn await Promise.all(promises);\n\t} else if (model.includes('imagen') || model.includes('flash-image')) {\n\t\t// Imagen models use a different endpoint and request/response structure\n\t\tconst sampleCount = this.getNodeParameter('options.sampleCount', i, 1) as number;\n\t\tconst body = {\n\t\t\tinstances: [\n\t\t\t\t{\n\t\t\t\t\tprompt,\n\t\t\t\t},\n\t\t\t],\n\t\t\tparameters: {\n\t\t\t\tsampleCount,\n\t\t\t},\n\t\t};\n\t\tconst response = (await apiRequest.call(this, 'POST', `/v1beta/${model}:predict`, {\n\t\t\tbody,\n\t\t})) as ImagenResponse;\n\n\t\tconst promises = response.predictions.map(async (prediction) => {\n\t\t\tconst buffer = Buffer.from(prediction.bytesBase64Encoded ?? '', 'base64');\n\t\t\tconst binaryData = await this.helpers.prepareBinaryData(\n\t\t\t\tbuffer,\n\t\t\t\t'image.png',\n\t\t\t\tprediction.mimeType,\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tbinary: {\n\t\t\t\t\t[binaryPropertyOutput]: binaryData,\n\t\t\t\t},\n\t\t\t\tjson: {\n\t\t\t\t\t...binaryData,\n\t\t\t\t\tdata: undefined,\n\t\t\t\t},\n\t\t\t\tpairedItem: { item: i },\n\t\t\t};\n\t\t});\n\n\t\treturn await Promise.all(promises);\n\t}\n\n\tthrow new NodeOperationError(\n\t\tthis.getNode(),\n\t\t`Model ${model} is not supported for image generation`,\n\t\t{\n\t\t\tdescription: 'Please check the model ID and try again.',\n\t\t},\n\t);\n}\n"],"mappings":"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","names":[]}