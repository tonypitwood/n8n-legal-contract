{"version":3,"sources":["../../../../../nodes/chains/ChainLLM/methods/promptUtils.ts"],"sourcesContent":["import { HumanMessage } from '@langchain/core/messages';\nimport type { BaseMessagePromptTemplateLike } from '@langchain/core/prompts';\nimport {\n\tAIMessagePromptTemplate,\n\tPromptTemplate,\n\tSystemMessagePromptTemplate,\n\tHumanMessagePromptTemplate,\n\tChatPromptTemplate,\n} from '@langchain/core/prompts';\nimport type { IExecuteFunctions } from 'n8n-workflow';\nimport { OperationalError } from 'n8n-workflow';\n\nimport { isChatInstance } from '@utils/helpers';\n\nimport { createImageMessage } from './imageUtils';\nimport type { MessageTemplate, PromptParams } from './types';\n\n/**\n * Creates a basic query template that may include format instructions\n */\nfunction buildQueryTemplate(formatInstructions?: string): PromptTemplate {\n\treturn new PromptTemplate({\n\t\ttemplate: `{query}${formatInstructions ? '\\n{formatInstructions}' : ''}`,\n\t\tinputVariables: ['query'],\n\t\tpartialVariables: formatInstructions ? { formatInstructions } : undefined,\n\t});\n}\n\n/**\n * Process an array of message templates into LangChain message objects\n */\nasync function processMessageTemplates({\n\tcontext,\n\titemIndex,\n\tmessages,\n}: {\n\tcontext: IExecuteFunctions;\n\titemIndex: number;\n\tmessages: MessageTemplate[];\n}): Promise<BaseMessagePromptTemplateLike[]> {\n\treturn await Promise.all(\n\t\tmessages.map(async (message) => {\n\t\t\t// Find the appropriate message class based on type\n\t\t\tconst messageClass = [\n\t\t\t\tSystemMessagePromptTemplate,\n\t\t\t\tAIMessagePromptTemplate,\n\t\t\t\tHumanMessagePromptTemplate,\n\t\t\t].find((m) => m.lc_name() === message.type);\n\n\t\t\tif (!messageClass) {\n\t\t\t\tthrow new OperationalError('Invalid message type', {\n\t\t\t\t\textra: { messageType: message.type },\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Handle image messages specially for human messages\n\t\t\tif (messageClass === HumanMessagePromptTemplate && message.messageType !== 'text') {\n\t\t\t\treturn await createImageMessage({ context, itemIndex, message });\n\t\t\t}\n\n\t\t\t// Process text messages\n\t\t\t// Escape curly braces in the message to prevent LangChain from treating them as variables\n\t\t\treturn messageClass.fromTemplate(\n\t\t\t\t(message.message || '').replace(/[{}]/g, (match) => match + match),\n\t\t\t);\n\t\t}),\n\t);\n}\n\n/**\n * Finalizes the prompt template by adding or updating the query in the message chain\n */\nasync function finalizePromptTemplate({\n\tparsedMessages,\n\tqueryTemplate,\n\tquery,\n}: {\n\tparsedMessages: BaseMessagePromptTemplateLike[];\n\tqueryTemplate: PromptTemplate;\n\tquery?: string;\n}): Promise<ChatPromptTemplate> {\n\t// Check if the last message is a human message with multi-content array\n\tconst lastMessage = parsedMessages[parsedMessages.length - 1];\n\n\tif (lastMessage instanceof HumanMessage && Array.isArray(lastMessage.content)) {\n\t\t// Add the query to the existing human message content\n\t\tconst humanMessage = new HumanMessagePromptTemplate(queryTemplate);\n\n\t\t// Format the message with the query and add the content synchronously\n\t\tconst formattedMessage = await humanMessage.format({ query });\n\n\t\t// Create a new array with the existing content plus the new item\n\t\tif (Array.isArray(lastMessage.content)) {\n\t\t\t// Clone the current content array and add the new item\n\t\t\tconst updatedContent = [\n\t\t\t\t...lastMessage.content,\n\t\t\t\t{\n\t\t\t\t\ttext: formattedMessage.content.toString(),\n\t\t\t\t\ttype: 'text',\n\t\t\t\t},\n\t\t\t];\n\n\t\t\t// Replace the content with the updated array\n\t\t\tlastMessage.content = updatedContent;\n\t\t}\n\t} else {\n\t\t// Otherwise, add a new human message with the query\n\t\tparsedMessages.push(new HumanMessagePromptTemplate(queryTemplate));\n\t}\n\n\treturn ChatPromptTemplate.fromMessages(parsedMessages);\n}\n\n/**\n * Builds the appropriate prompt template based on model type (chat vs completion)\n * and provided messages\n */\nexport async function createPromptTemplate({\n\tcontext,\n\titemIndex,\n\tllm,\n\tmessages,\n\tformatInstructions,\n\tquery,\n}: PromptParams) {\n\t// Create base query template\n\tconst queryTemplate = buildQueryTemplate(formatInstructions);\n\n\t// For non-chat models, just return the query template\n\tif (!isChatInstance(llm)) {\n\t\treturn queryTemplate;\n\t}\n\n\t// For chat models, process the messages if provided\n\tconst parsedMessages = messages?.length\n\t\t? await processMessageTemplates({ context, itemIndex, messages })\n\t\t: [];\n\n\t// Add or update the query in the message chain\n\treturn await finalizePromptTemplate({\n\t\tparsedMessages,\n\t\tqueryTemplate,\n\t\tquery,\n\t});\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAA6B;AAE7B,qBAMO;AAEP,0BAAiC;AAEjC,qBAA+B;AAE/B,wBAAmC;AAMnC,SAAS,mBAAmB,oBAA6C;AACxE,SAAO,IAAI,8BAAe;AAAA,IACzB,UAAU,UAAU,qBAAqB,2BAA2B,EAAE;AAAA,IACtE,gBAAgB,CAAC,OAAO;AAAA,IACxB,kBAAkB,qBAAqB,EAAE,mBAAmB,IAAI;AAAA,EACjE,CAAC;AACF;AAKA,eAAe,wBAAwB;AAAA,EACtC;AAAA,EACA;AAAA,EACA;AACD,GAI6C;AAC5C,SAAO,MAAM,QAAQ;AAAA,IACpB,SAAS,IAAI,OAAO,YAAY;AAE/B,YAAM,eAAe;AAAA,QACpB;AAAA,QACA;AAAA,QACA;AAAA,MACD,EAAE,KAAK,CAAC,MAAM,EAAE,QAAQ,MAAM,QAAQ,IAAI;AAE1C,UAAI,CAAC,cAAc;AAClB,cAAM,IAAI,qCAAiB,wBAAwB;AAAA,UAClD,OAAO,EAAE,aAAa,QAAQ,KAAK;AAAA,QACpC,CAAC;AAAA,MACF;AAGA,UAAI,iBAAiB,6CAA8B,QAAQ,gBAAgB,QAAQ;AAClF,eAAO,UAAM,sCAAmB,EAAE,SAAS,WAAW,QAAQ,CAAC;AAAA,MAChE;AAIA,aAAO,aAAa;AAAA,SAClB,QAAQ,WAAW,IAAI,QAAQ,SAAS,CAAC,UAAU,QAAQ,KAAK;AAAA,MAClE;AAAA,IACD,CAAC;AAAA,EACF;AACD;AAKA,eAAe,uBAAuB;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AACD,GAIgC;AAE/B,QAAM,cAAc,eAAe,eAAe,SAAS,CAAC;AAE5D,MAAI,uBAAuB,gCAAgB,MAAM,QAAQ,YAAY,OAAO,GAAG;AAE9E,UAAM,eAAe,IAAI,0CAA2B,aAAa;AAGjE,UAAM,mBAAmB,MAAM,aAAa,OAAO,EAAE,MAAM,CAAC;AAG5D,QAAI,MAAM,QAAQ,YAAY,OAAO,GAAG;AAEvC,YAAM,iBAAiB;AAAA,QACtB,GAAG,YAAY;AAAA,QACf;AAAA,UACC,MAAM,iBAAiB,QAAQ,SAAS;AAAA,UACxC,MAAM;AAAA,QACP;AAAA,MACD;AAGA,kBAAY,UAAU;AAAA,IACvB;AAAA,EACD,OAAO;AAEN,mBAAe,KAAK,IAAI,0CAA2B,aAAa,CAAC;AAAA,EAClE;AAEA,SAAO,kCAAmB,aAAa,cAAc;AACtD;AAMA,eAAsB,qBAAqB;AAAA,EAC1C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD,GAAiB;AAEhB,QAAM,gBAAgB,mBAAmB,kBAAkB;AAG3D,MAAI,KAAC,+BAAe,GAAG,GAAG;AACzB,WAAO;AAAA,EACR;AAGA,QAAM,iBAAiB,UAAU,SAC9B,MAAM,wBAAwB,EAAE,SAAS,WAAW,SAAS,CAAC,IAC9D,CAAC;AAGJ,SAAO,MAAM,uBAAuB;AAAA,IACnC;AAAA,IACA;AAAA,IACA;AAAA,EACD,CAAC;AACF;","names":[]}