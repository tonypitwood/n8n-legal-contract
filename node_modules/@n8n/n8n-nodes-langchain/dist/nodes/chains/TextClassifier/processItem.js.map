{"version":3,"sources":["../../../../nodes/chains/TextClassifier/processItem.ts"],"sourcesContent":["import type { BaseLanguageModel } from '@langchain/core/language_models/base';\nimport { HumanMessage } from '@langchain/core/messages';\nimport { ChatPromptTemplate, SystemMessagePromptTemplate } from '@langchain/core/prompts';\nimport type { OutputFixingParser, StructuredOutputParser } from 'langchain/output_parsers';\nimport { NodeOperationError, type IExecuteFunctions, type INodeExecutionData } from 'n8n-workflow';\n\nimport { getTracingConfig } from '@utils/tracing';\n\nimport { SYSTEM_PROMPT_TEMPLATE } from './constants';\n\nexport async function processItem(\n\tctx: IExecuteFunctions,\n\titemIndex: number,\n\titem: INodeExecutionData,\n\tllm: BaseLanguageModel,\n\tparser: StructuredOutputParser<any> | OutputFixingParser<any>,\n\tcategories: Array<{ category: string; description: string }>,\n\tmultiClassPrompt: string,\n\tfallbackPrompt: string | undefined,\n): Promise<Record<string, unknown>> {\n\tconst input = ctx.getNodeParameter('inputText', itemIndex) as string;\n\n\tif (!input) {\n\t\tthrow new NodeOperationError(\n\t\t\tctx.getNode(),\n\t\t\t`Text to classify for item ${itemIndex} is not defined`,\n\t\t);\n\t}\n\n\titem.pairedItem = { item: itemIndex };\n\n\tconst inputPrompt = new HumanMessage(input);\n\n\tconst systemPromptTemplateOpt = ctx.getNodeParameter(\n\t\t'options.systemPromptTemplate',\n\t\titemIndex,\n\t\tSYSTEM_PROMPT_TEMPLATE,\n\t) as string;\n\tconst systemPromptTemplate = SystemMessagePromptTemplate.fromTemplate(\n\t\t`${systemPromptTemplateOpt ?? SYSTEM_PROMPT_TEMPLATE}\n\t{format_instructions}\n\t${multiClassPrompt}\n\t${fallbackPrompt}`,\n\t);\n\n\tconst messages = [\n\t\tawait systemPromptTemplate.format({\n\t\t\tcategories: categories.map((cat) => cat.category).join(', '),\n\t\t\tformat_instructions: parser.getFormatInstructions(),\n\t\t}),\n\t\tinputPrompt,\n\t];\n\tconst prompt = ChatPromptTemplate.fromMessages(messages);\n\tconst chain = prompt.pipe(llm).pipe(parser).withConfig(getTracingConfig(ctx));\n\n\treturn await chain.invoke(messages);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,sBAA6B;AAC7B,qBAAgE;AAEhE,0BAAoF;AAEpF,qBAAiC;AAEjC,uBAAuC;AAEvC,eAAsB,YACrB,KACA,WACA,MACA,KACA,QACA,YACA,kBACA,gBACmC;AACnC,QAAM,QAAQ,IAAI,iBAAiB,aAAa,SAAS;AAEzD,MAAI,CAAC,OAAO;AACX,UAAM,IAAI;AAAA,MACT,IAAI,QAAQ;AAAA,MACZ,6BAA6B,SAAS;AAAA,IACvC;AAAA,EACD;AAEA,OAAK,aAAa,EAAE,MAAM,UAAU;AAEpC,QAAM,cAAc,IAAI,6BAAa,KAAK;AAE1C,QAAM,0BAA0B,IAAI;AAAA,IACnC;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACA,QAAM,uBAAuB,2CAA4B;AAAA,IACxD,GAAG,2BAA2B,uCAAsB;AAAA;AAAA,GAEnD,gBAAgB;AAAA,GAChB,cAAc;AAAA,EAChB;AAEA,QAAM,WAAW;AAAA,IAChB,MAAM,qBAAqB,OAAO;AAAA,MACjC,YAAY,WAAW,IAAI,CAAC,QAAQ,IAAI,QAAQ,EAAE,KAAK,IAAI;AAAA,MAC3D,qBAAqB,OAAO,sBAAsB;AAAA,IACnD,CAAC;AAAA,IACD;AAAA,EACD;AACA,QAAM,SAAS,kCAAmB,aAAa,QAAQ;AACvD,QAAM,QAAQ,OAAO,KAAK,GAAG,EAAE,KAAK,MAAM,EAAE,eAAW,iCAAiB,GAAG,CAAC;AAE5E,SAAO,MAAM,MAAM,OAAO,QAAQ;AACnC;","names":[]}