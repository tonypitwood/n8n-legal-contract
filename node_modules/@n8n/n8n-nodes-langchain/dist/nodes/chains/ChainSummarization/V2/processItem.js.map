{"version":3,"sources":["../../../../../nodes/chains/ChainSummarization/V2/processItem.ts"],"sourcesContent":["import type { Document } from '@langchain/core/documents';\nimport type { BaseLanguageModel } from '@langchain/core/language_models/base';\nimport type { ChainValues } from '@langchain/core/utils/types';\nimport { RecursiveCharacterTextSplitter, type TextSplitter } from '@langchain/textsplitters';\nimport { loadSummarizationChain } from 'langchain/chains';\nimport { type IExecuteFunctions, type INodeExecutionData, NodeConnectionTypes } from 'n8n-workflow';\n\nimport { N8nBinaryLoader } from '@utils/N8nBinaryLoader';\nimport { N8nJsonLoader } from '@utils/N8nJsonLoader';\nimport { getTracingConfig } from '@utils/tracing';\n\nimport { getChainPromptsArgs } from '../helpers';\n\nexport async function processItem(\n\tctx: IExecuteFunctions,\n\titemIndex: number,\n\titem: INodeExecutionData,\n\toperationMode: string,\n\tchunkingMode: 'simple' | 'advanced' | 'none',\n): Promise<ChainValues | undefined> {\n\tconst model = (await ctx.getInputConnectionData(\n\t\tNodeConnectionTypes.AiLanguageModel,\n\t\t0,\n\t)) as BaseLanguageModel;\n\n\tconst summarizationMethodAndPrompts = ctx.getNodeParameter(\n\t\t'options.summarizationMethodAndPrompts.values',\n\t\titemIndex,\n\t\t{},\n\t) as {\n\t\tprompt?: string;\n\t\trefineQuestionPrompt?: string;\n\t\trefinePrompt?: string;\n\t\tsummarizationMethod: 'map_reduce' | 'stuff' | 'refine';\n\t\tcombineMapPrompt?: string;\n\t};\n\n\tconst chainArgs = getChainPromptsArgs(\n\t\tsummarizationMethodAndPrompts.summarizationMethod ?? 'map_reduce',\n\t\tsummarizationMethodAndPrompts,\n\t);\n\n\tconst chain = loadSummarizationChain(model, chainArgs);\n\n\tlet processedDocuments: Document[];\n\n\t// Use dedicated document loader input to load documents\n\tif (operationMode === 'documentLoader') {\n\t\tconst documentInput = (await ctx.getInputConnectionData(NodeConnectionTypes.AiDocument, 0)) as\n\t\t\t| N8nJsonLoader\n\t\t\t| Array<Document<Record<string, unknown>>>;\n\n\t\tconst isN8nLoader =\n\t\t\tdocumentInput instanceof N8nJsonLoader || documentInput instanceof N8nBinaryLoader;\n\n\t\tprocessedDocuments = isN8nLoader\n\t\t\t? await documentInput.processItem(item, itemIndex)\n\t\t\t: documentInput;\n\n\t\treturn await chain.withConfig(getTracingConfig(ctx)).invoke({\n\t\t\tinput_documents: processedDocuments,\n\t\t});\n\t} else if (['nodeInputJson', 'nodeInputBinary'].includes(operationMode)) {\n\t\t// Take the input and use binary or json loader\n\t\tlet textSplitter: TextSplitter | undefined;\n\n\t\tswitch (chunkingMode) {\n\t\t\t// In simple mode we use recursive character splitter with default settings\n\t\t\tcase 'simple':\n\t\t\t\tconst chunkSize = ctx.getNodeParameter('chunkSize', itemIndex, 1000) as number;\n\t\t\t\tconst chunkOverlap = ctx.getNodeParameter('chunkOverlap', itemIndex, 200) as number;\n\n\t\t\t\ttextSplitter = new RecursiveCharacterTextSplitter({ chunkOverlap, chunkSize });\n\t\t\t\tbreak;\n\n\t\t\t// In advanced mode user can connect text splitter node so we just retrieve it\n\t\t\tcase 'advanced':\n\t\t\t\ttextSplitter = (await ctx.getInputConnectionData(NodeConnectionTypes.AiTextSplitter, 0)) as\n\t\t\t\t\t| TextSplitter\n\t\t\t\t\t| undefined;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet processor: N8nJsonLoader | N8nBinaryLoader;\n\t\tif (operationMode === 'nodeInputBinary') {\n\t\t\tconst binaryDataKey = ctx.getNodeParameter(\n\t\t\t\t'options.binaryDataKey',\n\t\t\t\titemIndex,\n\t\t\t\t'data',\n\t\t\t) as string;\n\t\t\tprocessor = new N8nBinaryLoader(ctx, 'options.', binaryDataKey, textSplitter);\n\t\t} else {\n\t\t\tprocessor = new N8nJsonLoader(ctx, 'options.', textSplitter);\n\t\t}\n\n\t\tconst processedItem = await processor.processItem(item, itemIndex);\n\t\treturn await chain.invoke(\n\t\t\t{\n\t\t\t\tinput_documents: processedItem,\n\t\t\t},\n\t\t\t{ signal: ctx.getExecutionCancelSignal() },\n\t\t);\n\t}\n\treturn undefined;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,2BAAkE;AAClE,oBAAuC;AACvC,0BAAqF;AAErF,6BAAgC;AAChC,2BAA8B;AAC9B,qBAAiC;AAEjC,qBAAoC;AAEpC,eAAsB,YACrB,KACA,WACA,MACA,eACA,cACmC;AACnC,QAAM,QAAS,MAAM,IAAI;AAAA,IACxB,wCAAoB;AAAA,IACpB;AAAA,EACD;AAEA,QAAM,gCAAgC,IAAI;AAAA,IACzC;AAAA,IACA;AAAA,IACA,CAAC;AAAA,EACF;AAQA,QAAM,gBAAY;AAAA,IACjB,8BAA8B,uBAAuB;AAAA,IACrD;AAAA,EACD;AAEA,QAAM,YAAQ,sCAAuB,OAAO,SAAS;AAErD,MAAI;AAGJ,MAAI,kBAAkB,kBAAkB;AACvC,UAAM,gBAAiB,MAAM,IAAI,uBAAuB,wCAAoB,YAAY,CAAC;AAIzF,UAAM,cACL,yBAAyB,sCAAiB,yBAAyB;AAEpE,yBAAqB,cAClB,MAAM,cAAc,YAAY,MAAM,SAAS,IAC/C;AAEH,WAAO,MAAM,MAAM,eAAW,iCAAiB,GAAG,CAAC,EAAE,OAAO;AAAA,MAC3D,iBAAiB;AAAA,IAClB,CAAC;AAAA,EACF,WAAW,CAAC,iBAAiB,iBAAiB,EAAE,SAAS,aAAa,GAAG;AAExE,QAAI;AAEJ,YAAQ,cAAc;AAAA;AAAA,MAErB,KAAK;AACJ,cAAM,YAAY,IAAI,iBAAiB,aAAa,WAAW,GAAI;AACnE,cAAM,eAAe,IAAI,iBAAiB,gBAAgB,WAAW,GAAG;AAExE,uBAAe,IAAI,oDAA+B,EAAE,cAAc,UAAU,CAAC;AAC7E;AAAA;AAAA,MAGD,KAAK;AACJ,uBAAgB,MAAM,IAAI,uBAAuB,wCAAoB,gBAAgB,CAAC;AAGtF;AAAA,MACD;AACC;AAAA,IACF;AAEA,QAAI;AACJ,QAAI,kBAAkB,mBAAmB;AACxC,YAAM,gBAAgB,IAAI;AAAA,QACzB;AAAA,QACA;AAAA,QACA;AAAA,MACD;AACA,kBAAY,IAAI,uCAAgB,KAAK,YAAY,eAAe,YAAY;AAAA,IAC7E,OAAO;AACN,kBAAY,IAAI,mCAAc,KAAK,YAAY,YAAY;AAAA,IAC5D;AAEA,UAAM,gBAAgB,MAAM,UAAU,YAAY,MAAM,SAAS;AACjE,WAAO,MAAM,MAAM;AAAA,MAClB;AAAA,QACC,iBAAiB;AAAA,MAClB;AAAA,MACA,EAAE,QAAQ,IAAI,yBAAyB,EAAE;AAAA,IAC1C;AAAA,EACD;AACA,SAAO;AACR;","names":[]}