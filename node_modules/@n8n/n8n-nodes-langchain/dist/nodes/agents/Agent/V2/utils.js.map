{"version":3,"sources":["../../../../../nodes/agents/Agent/V2/utils.ts"],"sourcesContent":["// Function used in the inputs expression to figure out which inputs to\n\nimport {\n\ttype INodeInputConfiguration,\n\ttype INodeInputFilter,\n\ttype NodeConnectionType,\n} from 'n8n-workflow';\n\n// display based on the agent type\nexport function getInputs(\n\thasMainInput?: boolean,\n\thasOutputParser?: boolean,\n\tneedsFallback?: boolean,\n): Array<NodeConnectionType | INodeInputConfiguration> {\n\tinterface SpecialInput {\n\t\ttype: NodeConnectionType;\n\t\tfilter?: INodeInputFilter;\n\t\tdisplayName: string;\n\t\trequired?: boolean;\n\t}\n\n\tconst getInputData = (\n\t\tinputs: SpecialInput[],\n\t): Array<NodeConnectionType | INodeInputConfiguration> => {\n\t\treturn inputs.map(({ type, filter, displayName, required }) => {\n\t\t\tconst input: INodeInputConfiguration = {\n\t\t\t\ttype,\n\t\t\t\tdisplayName,\n\t\t\t\trequired,\n\t\t\t\tmaxConnections: ['ai_languageModel', 'ai_memory', 'ai_outputParser'].includes(type)\n\t\t\t\t\t? 1\n\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\tif (filter) {\n\t\t\t\tinput.filter = filter;\n\t\t\t}\n\n\t\t\treturn input;\n\t\t});\n\t};\n\n\tlet specialInputs: SpecialInput[] = [\n\t\t{\n\t\t\ttype: 'ai_languageModel',\n\t\t\tdisplayName: 'Chat Model',\n\t\t\trequired: true,\n\t\t\tfilter: {\n\t\t\t\texcludedNodes: [\n\t\t\t\t\t'@n8n/n8n-nodes-langchain.lmCohere',\n\t\t\t\t\t'@n8n/n8n-nodes-langchain.lmOllama',\n\t\t\t\t\t'n8n/n8n-nodes-langchain.lmOpenAi',\n\t\t\t\t\t'@n8n/n8n-nodes-langchain.lmOpenHuggingFaceInference',\n\t\t\t\t],\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\ttype: 'ai_languageModel',\n\t\t\tdisplayName: 'Fallback Model',\n\t\t\trequired: true,\n\t\t\tfilter: {\n\t\t\t\texcludedNodes: [\n\t\t\t\t\t'@n8n/n8n-nodes-langchain.lmCohere',\n\t\t\t\t\t'@n8n/n8n-nodes-langchain.lmOllama',\n\t\t\t\t\t'n8n/n8n-nodes-langchain.lmOpenAi',\n\t\t\t\t\t'@n8n/n8n-nodes-langchain.lmOpenHuggingFaceInference',\n\t\t\t\t],\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Memory',\n\t\t\ttype: 'ai_memory',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Tool',\n\t\t\ttype: 'ai_tool',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Output Parser',\n\t\t\ttype: 'ai_outputParser',\n\t\t},\n\t];\n\n\tif (hasOutputParser === false) {\n\t\tspecialInputs = specialInputs.filter((input) => input.type !== 'ai_outputParser');\n\t}\n\tif (needsFallback === false) {\n\t\tspecialInputs = specialInputs.filter((input) => input.displayName !== 'Fallback Model');\n\t}\n\n\t// Note cannot use NodeConnectionType.Main\n\t// otherwise expression won't evaluate correctly on the FE\n\tconst mainInputs = hasMainInput ? ['main' as NodeConnectionType] : [];\n\treturn [...mainInputs, ...getInputData(specialInputs)];\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AASO,SAAS,UACf,cACA,iBACA,eACsD;AAQtD,QAAM,eAAe,CACpB,WACyD;AACzD,WAAO,OAAO,IAAI,CAAC,EAAE,MAAM,QAAQ,aAAa,SAAS,MAAM;AAC9D,YAAM,QAAiC;AAAA,QACtC;AAAA,QACA;AAAA,QACA;AAAA,QACA,gBAAgB,CAAC,oBAAoB,aAAa,iBAAiB,EAAE,SAAS,IAAI,IAC/E,IACA;AAAA,MACJ;AAEA,UAAI,QAAQ;AACX,cAAM,SAAS;AAAA,MAChB;AAEA,aAAO;AAAA,IACR,CAAC;AAAA,EACF;AAEA,MAAI,gBAAgC;AAAA,IACnC;AAAA,MACC,MAAM;AAAA,MACN,aAAa;AAAA,MACb,UAAU;AAAA,MACV,QAAQ;AAAA,QACP,eAAe;AAAA,UACd;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,IACA;AAAA,MACC,MAAM;AAAA,MACN,aAAa;AAAA,MACb,UAAU;AAAA,MACV,QAAQ;AAAA,QACP,eAAe;AAAA,UACd;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,IACP;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,IACP;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,IACP;AAAA,EACD;AAEA,MAAI,oBAAoB,OAAO;AAC9B,oBAAgB,cAAc,OAAO,CAAC,UAAU,MAAM,SAAS,iBAAiB;AAAA,EACjF;AACA,MAAI,kBAAkB,OAAO;AAC5B,oBAAgB,cAAc,OAAO,CAAC,UAAU,MAAM,gBAAgB,gBAAgB;AAAA,EACvF;AAIA,QAAM,aAAa,eAAe,CAAC,MAA4B,IAAI,CAAC;AACpE,SAAO,CAAC,GAAG,YAAY,GAAG,aAAa,aAAa,CAAC;AACtD;","names":[]}