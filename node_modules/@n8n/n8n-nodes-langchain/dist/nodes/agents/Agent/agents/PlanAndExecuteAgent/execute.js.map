{"version":3,"sources":["../../../../../../nodes/agents/Agent/agents/PlanAndExecuteAgent/execute.ts"],"sourcesContent":["import type { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport { PromptTemplate } from '@langchain/core/prompts';\nimport { PlanAndExecuteAgentExecutor } from 'langchain/experimental/plan_and_execute';\nimport {\n\ttype IExecuteFunctions,\n\ttype INodeExecutionData,\n\tNodeConnectionTypes,\n\tNodeOperationError,\n} from 'n8n-workflow';\n\nimport { getConnectedTools, getPromptInputByType } from '@utils/helpers';\nimport { getOptionalOutputParser } from '@utils/output_parsers/N8nOutputParser';\nimport { throwIfToolSchema } from '@utils/schemaParsing';\nimport { getTracingConfig } from '@utils/tracing';\n\nimport { checkForStructuredTools, extractParsedOutput } from '../utils';\n\nexport async function planAndExecuteAgentExecute(\n\tthis: IExecuteFunctions,\n\tnodeVersion: number,\n): Promise<INodeExecutionData[][]> {\n\tthis.logger.debug('Executing PlanAndExecute Agent');\n\tconst model = (await this.getInputConnectionData(\n\t\tNodeConnectionTypes.AiLanguageModel,\n\t\t0,\n\t)) as BaseChatModel;\n\n\tconst tools = await getConnectedTools(this, nodeVersion >= 1.5, true, true);\n\n\tawait checkForStructuredTools(tools, this.getNode(), 'Plan & Execute Agent');\n\tconst outputParser = await getOptionalOutputParser(this);\n\n\tconst options = this.getNodeParameter('options', 0, {}) as {\n\t\thumanMessageTemplate?: string;\n\t};\n\n\tconst agentExecutor = await PlanAndExecuteAgentExecutor.fromLLMAndTools({\n\t\tllm: model,\n\t\ttools,\n\t\thumanMessageTemplate: options.humanMessageTemplate,\n\t});\n\n\tconst returnData: INodeExecutionData[] = [];\n\n\tlet prompt: PromptTemplate | undefined;\n\tif (outputParser) {\n\t\tconst formatInstructions = outputParser.getFormatInstructions();\n\n\t\tprompt = new PromptTemplate({\n\t\t\ttemplate: '{input}\\n{formatInstructions}',\n\t\t\tinputVariables: ['input'],\n\t\t\tpartialVariables: { formatInstructions },\n\t\t});\n\t}\n\n\tconst items = this.getInputData();\n\tfor (let itemIndex = 0; itemIndex < items.length; itemIndex++) {\n\t\ttry {\n\t\t\tlet input;\n\t\t\tif (this.getNode().typeVersion <= 1.2) {\n\t\t\t\tinput = this.getNodeParameter('text', itemIndex) as string;\n\t\t\t} else {\n\t\t\t\tinput = getPromptInputByType({\n\t\t\t\t\tctx: this,\n\t\t\t\t\ti: itemIndex,\n\t\t\t\t\tinputKey: 'text',\n\t\t\t\t\tpromptTypeKey: 'promptType',\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (input === undefined) {\n\t\t\t\tthrow new NodeOperationError(this.getNode(), 'The ‘text‘ parameter is empty.');\n\t\t\t}\n\n\t\t\tif (prompt) {\n\t\t\t\tinput = (await prompt.invoke({ input })).value;\n\t\t\t}\n\n\t\t\tconst response = await agentExecutor\n\t\t\t\t.withConfig(getTracingConfig(this))\n\t\t\t\t.invoke({ input, outputParser });\n\n\t\t\tif (outputParser) {\n\t\t\t\tresponse.output = await extractParsedOutput(this, outputParser, response.output as string);\n\t\t\t}\n\n\t\t\treturnData.push({ json: response });\n\t\t} catch (error) {\n\t\t\tthrowIfToolSchema(this, error);\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push({ json: { error: error.message }, pairedItem: { item: itemIndex } });\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\treturn [returnData];\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,qBAA+B;AAC/B,8BAA4C;AAC5C,0BAKO;AAEP,qBAAwD;AACxD,6BAAwC;AACxC,2BAAkC;AAClC,qBAAiC;AAEjC,mBAA6D;AAE7D,eAAsB,2BAErB,aACkC;AAClC,OAAK,OAAO,MAAM,gCAAgC;AAClD,QAAM,QAAS,MAAM,KAAK;AAAA,IACzB,wCAAoB;AAAA,IACpB;AAAA,EACD;AAEA,QAAM,QAAQ,UAAM,kCAAkB,MAAM,eAAe,KAAK,MAAM,IAAI;AAE1E,YAAM,sCAAwB,OAAO,KAAK,QAAQ,GAAG,sBAAsB;AAC3E,QAAM,eAAe,UAAM,gDAAwB,IAAI;AAEvD,QAAM,UAAU,KAAK,iBAAiB,WAAW,GAAG,CAAC,CAAC;AAItD,QAAM,gBAAgB,MAAM,oDAA4B,gBAAgB;AAAA,IACvE,KAAK;AAAA,IACL;AAAA,IACA,sBAAsB,QAAQ;AAAA,EAC/B,CAAC;AAED,QAAM,aAAmC,CAAC;AAE1C,MAAI;AACJ,MAAI,cAAc;AACjB,UAAM,qBAAqB,aAAa,sBAAsB;AAE9D,aAAS,IAAI,8BAAe;AAAA,MAC3B,UAAU;AAAA,MACV,gBAAgB,CAAC,OAAO;AAAA,MACxB,kBAAkB,EAAE,mBAAmB;AAAA,IACxC,CAAC;AAAA,EACF;AAEA,QAAM,QAAQ,KAAK,aAAa;AAChC,WAAS,YAAY,GAAG,YAAY,MAAM,QAAQ,aAAa;AAC9D,QAAI;AACH,UAAI;AACJ,UAAI,KAAK,QAAQ,EAAE,eAAe,KAAK;AACtC,gBAAQ,KAAK,iBAAiB,QAAQ,SAAS;AAAA,MAChD,OAAO;AACN,oBAAQ,qCAAqB;AAAA,UAC5B,KAAK;AAAA,UACL,GAAG;AAAA,UACH,UAAU;AAAA,UACV,eAAe;AAAA,QAChB,CAAC;AAAA,MACF;AAEA,UAAI,UAAU,QAAW;AACxB,cAAM,IAAI,uCAAmB,KAAK,QAAQ,GAAG,0CAAgC;AAAA,MAC9E;AAEA,UAAI,QAAQ;AACX,iBAAS,MAAM,OAAO,OAAO,EAAE,MAAM,CAAC,GAAG;AAAA,MAC1C;AAEA,YAAM,WAAW,MAAM,cACrB,eAAW,iCAAiB,IAAI,CAAC,EACjC,OAAO,EAAE,OAAO,aAAa,CAAC;AAEhC,UAAI,cAAc;AACjB,iBAAS,SAAS,UAAM,kCAAoB,MAAM,cAAc,SAAS,MAAgB;AAAA,MAC1F;AAEA,iBAAW,KAAK,EAAE,MAAM,SAAS,CAAC;AAAA,IACnC,SAAS,OAAO;AACf,kDAAkB,MAAM,KAAK;AAC7B,UAAI,KAAK,eAAe,GAAG;AAC1B,mBAAW,KAAK,EAAE,MAAM,EAAE,OAAO,MAAM,QAAQ,GAAG,YAAY,EAAE,MAAM,UAAU,EAAE,CAAC;AACnF;AAAA,MACD;AAEA,YAAM;AAAA,IACP;AAAA,EACD;AAEA,SAAO,CAAC,UAAU;AACnB;","names":[]}