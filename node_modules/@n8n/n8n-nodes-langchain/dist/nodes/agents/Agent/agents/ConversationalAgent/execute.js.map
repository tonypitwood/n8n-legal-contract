{"version":3,"sources":["../../../../../../nodes/agents/Agent/agents/ConversationalAgent/execute.ts"],"sourcesContent":["import type { BaseChatMemory } from '@langchain/community/memory/chat_memory';\nimport { PromptTemplate } from '@langchain/core/prompts';\nimport { initializeAgentExecutorWithOptions } from 'langchain/agents';\nimport type { IExecuteFunctions, INodeExecutionData } from 'n8n-workflow';\nimport { NodeConnectionTypes, NodeOperationError } from 'n8n-workflow';\n\nimport { isChatInstance, getPromptInputByType, getConnectedTools } from '@utils/helpers';\nimport { getOptionalOutputParser } from '@utils/output_parsers/N8nOutputParser';\nimport { throwIfToolSchema } from '@utils/schemaParsing';\nimport { getTracingConfig } from '@utils/tracing';\n\nimport { checkForStructuredTools, extractParsedOutput } from '../utils';\n\nexport async function conversationalAgentExecute(\n\tthis: IExecuteFunctions,\n\tnodeVersion: number,\n): Promise<INodeExecutionData[][]> {\n\tthis.logger.debug('Executing Conversational Agent');\n\tconst model = await this.getInputConnectionData(NodeConnectionTypes.AiLanguageModel, 0);\n\n\tif (!isChatInstance(model)) {\n\t\tthrow new NodeOperationError(this.getNode(), 'Conversational Agent requires Chat Model');\n\t}\n\n\tconst memory = (await this.getInputConnectionData(NodeConnectionTypes.AiMemory, 0)) as\n\t\t| BaseChatMemory\n\t\t| undefined;\n\n\tconst tools = await getConnectedTools(this, nodeVersion >= 1.5, true, true);\n\tconst outputParser = await getOptionalOutputParser(this);\n\n\tawait checkForStructuredTools(tools, this.getNode(), 'Conversational Agent');\n\n\t// TODO: Make it possible in the future to use values for other items than just 0\n\tconst options = this.getNodeParameter('options', 0, {}) as {\n\t\tsystemMessage?: string;\n\t\thumanMessage?: string;\n\t\tmaxIterations?: number;\n\t\treturnIntermediateSteps?: boolean;\n\t};\n\n\tconst agentExecutor = await initializeAgentExecutorWithOptions(tools, model, {\n\t\t// Passing \"chat-conversational-react-description\" as the agent type\n\t\t// automatically creates and uses BufferMemory with the executor.\n\t\t// If you would like to override this, you can pass in a custom\n\t\t// memory option, but the memoryKey set on it must be \"chat_history\".\n\t\tagentType: 'chat-conversational-react-description',\n\t\tmemory,\n\t\treturnIntermediateSteps: options?.returnIntermediateSteps === true,\n\t\tmaxIterations: options.maxIterations ?? 10,\n\t\tagentArgs: {\n\t\t\tsystemMessage: options.systemMessage,\n\t\t\thumanMessage: options.humanMessage,\n\t\t},\n\t});\n\n\tconst returnData: INodeExecutionData[] = [];\n\n\tlet prompt: PromptTemplate | undefined;\n\tif (outputParser) {\n\t\tconst formatInstructions = outputParser.getFormatInstructions();\n\n\t\tprompt = new PromptTemplate({\n\t\t\ttemplate: '{input}\\n{formatInstructions}',\n\t\t\tinputVariables: ['input'],\n\t\t\tpartialVariables: { formatInstructions },\n\t\t});\n\t}\n\n\tconst items = this.getInputData();\n\tfor (let itemIndex = 0; itemIndex < items.length; itemIndex++) {\n\t\ttry {\n\t\t\tlet input;\n\n\t\t\tif (this.getNode().typeVersion <= 1.2) {\n\t\t\t\tinput = this.getNodeParameter('text', itemIndex) as string;\n\t\t\t} else {\n\t\t\t\tinput = getPromptInputByType({\n\t\t\t\t\tctx: this,\n\t\t\t\t\ti: itemIndex,\n\t\t\t\t\tinputKey: 'text',\n\t\t\t\t\tpromptTypeKey: 'promptType',\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (input === undefined) {\n\t\t\t\tthrow new NodeOperationError(this.getNode(), 'The â€˜text parameter is empty.');\n\t\t\t}\n\n\t\t\tif (prompt) {\n\t\t\t\tinput = (await prompt.invoke({ input })).value;\n\t\t\t}\n\n\t\t\tconst response = await agentExecutor\n\t\t\t\t.withConfig(getTracingConfig(this))\n\t\t\t\t.invoke({ input, outputParser });\n\n\t\t\tif (outputParser) {\n\t\t\t\tresponse.output = await extractParsedOutput(this, outputParser, response.output as string);\n\t\t\t}\n\n\t\t\treturnData.push({ json: response });\n\t\t} catch (error) {\n\t\t\tthrowIfToolSchema(this, error);\n\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push({ json: { error: error.message }, pairedItem: { item: itemIndex } });\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\treturn [returnData];\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,qBAA+B;AAC/B,oBAAmD;AAEnD,0BAAwD;AAExD,qBAAwE;AACxE,6BAAwC;AACxC,2BAAkC;AAClC,qBAAiC;AAEjC,mBAA6D;AAE7D,eAAsB,2BAErB,aACkC;AAClC,OAAK,OAAO,MAAM,gCAAgC;AAClD,QAAM,QAAQ,MAAM,KAAK,uBAAuB,wCAAoB,iBAAiB,CAAC;AAEtF,MAAI,KAAC,+BAAe,KAAK,GAAG;AAC3B,UAAM,IAAI,uCAAmB,KAAK,QAAQ,GAAG,0CAA0C;AAAA,EACxF;AAEA,QAAM,SAAU,MAAM,KAAK,uBAAuB,wCAAoB,UAAU,CAAC;AAIjF,QAAM,QAAQ,UAAM,kCAAkB,MAAM,eAAe,KAAK,MAAM,IAAI;AAC1E,QAAM,eAAe,UAAM,gDAAwB,IAAI;AAEvD,YAAM,sCAAwB,OAAO,KAAK,QAAQ,GAAG,sBAAsB;AAG3E,QAAM,UAAU,KAAK,iBAAiB,WAAW,GAAG,CAAC,CAAC;AAOtD,QAAM,gBAAgB,UAAM,kDAAmC,OAAO,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA,IAK5E,WAAW;AAAA,IACX;AAAA,IACA,yBAAyB,SAAS,4BAA4B;AAAA,IAC9D,eAAe,QAAQ,iBAAiB;AAAA,IACxC,WAAW;AAAA,MACV,eAAe,QAAQ;AAAA,MACvB,cAAc,QAAQ;AAAA,IACvB;AAAA,EACD,CAAC;AAED,QAAM,aAAmC,CAAC;AAE1C,MAAI;AACJ,MAAI,cAAc;AACjB,UAAM,qBAAqB,aAAa,sBAAsB;AAE9D,aAAS,IAAI,8BAAe;AAAA,MAC3B,UAAU;AAAA,MACV,gBAAgB,CAAC,OAAO;AAAA,MACxB,kBAAkB,EAAE,mBAAmB;AAAA,IACxC,CAAC;AAAA,EACF;AAEA,QAAM,QAAQ,KAAK,aAAa;AAChC,WAAS,YAAY,GAAG,YAAY,MAAM,QAAQ,aAAa;AAC9D,QAAI;AACH,UAAI;AAEJ,UAAI,KAAK,QAAQ,EAAE,eAAe,KAAK;AACtC,gBAAQ,KAAK,iBAAiB,QAAQ,SAAS;AAAA,MAChD,OAAO;AACN,oBAAQ,qCAAqB;AAAA,UAC5B,KAAK;AAAA,UACL,GAAG;AAAA,UACH,UAAU;AAAA,UACV,eAAe;AAAA,QAChB,CAAC;AAAA,MACF;AAEA,UAAI,UAAU,QAAW;AACxB,cAAM,IAAI,uCAAmB,KAAK,QAAQ,GAAG,oCAA+B;AAAA,MAC7E;AAEA,UAAI,QAAQ;AACX,iBAAS,MAAM,OAAO,OAAO,EAAE,MAAM,CAAC,GAAG;AAAA,MAC1C;AAEA,YAAM,WAAW,MAAM,cACrB,eAAW,iCAAiB,IAAI,CAAC,EACjC,OAAO,EAAE,OAAO,aAAa,CAAC;AAEhC,UAAI,cAAc;AACjB,iBAAS,SAAS,UAAM,kCAAoB,MAAM,cAAc,SAAS,MAAgB;AAAA,MAC1F;AAEA,iBAAW,KAAK,EAAE,MAAM,SAAS,CAAC;AAAA,IACnC,SAAS,OAAO;AACf,kDAAkB,MAAM,KAAK;AAE7B,UAAI,KAAK,eAAe,GAAG;AAC1B,mBAAW,KAAK,EAAE,MAAM,EAAE,OAAO,MAAM,QAAQ,GAAG,YAAY,EAAE,MAAM,UAAU,EAAE,CAAC;AACnF;AAAA,MACD;AAEA,YAAM;AAAA,IACP;AAAA,EACD;AAEA,SAAO,CAAC,UAAU;AACnB;","names":[]}