{"version":3,"sources":["../../../../nodes/mcp/McpTrigger/McpServer.ts"],"sourcesContent":["import type { Tool } from '@langchain/core/tools';\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport type { RequestHandlerExtra } from '@modelcontextprotocol/sdk/shared/protocol.js';\nimport type {\n\tJSONRPCMessage,\n\tServerRequest,\n\tServerNotification,\n} from '@modelcontextprotocol/sdk/types.js';\nimport {\n\tJSONRPCMessageSchema,\n\tListToolsRequestSchema,\n\tCallToolRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport { randomUUID } from 'crypto';\nimport type * as express from 'express';\nimport type { IncomingMessage } from 'http';\nimport { jsonParse, OperationalError, type Logger } from 'n8n-workflow';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\n\nimport { FlushingSSEServerTransport, FlushingStreamableHTTPTransport } from './FlushingTransport';\nimport type { CompressionResponse } from './FlushingTransport';\n\n/**\n * Parses the JSONRPC message and checks whether the method used was a tool\n * call. This is necessary in order to not have executions for listing tools\n * and other commands sent by the MCP client\n */\nfunction wasToolCall(body: string) {\n\ttry {\n\t\tconst message: unknown = JSON.parse(body);\n\t\tconst parsedMessage: JSONRPCMessage = JSONRPCMessageSchema.parse(message);\n\t\treturn (\n\t\t\t'method' in parsedMessage &&\n\t\t\t'id' in parsedMessage &&\n\t\t\tparsedMessage?.method === CallToolRequestSchema.shape.method.value\n\t\t);\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Extracts the request ID from a JSONRPC message (for example for tool calls).\n * Returns undefined if the message doesn't have an ID (for example on a tool list request)\n *\n */\nfunction getRequestId(message: unknown): string | undefined {\n\ttry {\n\t\tconst parsedMessage: JSONRPCMessage = JSONRPCMessageSchema.parse(message);\n\t\treturn 'id' in parsedMessage ? String(parsedMessage.id) : undefined;\n\t} catch {\n\t\treturn undefined;\n\t}\n}\n\n/**\n * This singleton is shared across the instance, making sure it is the one\n * keeping account of MCP servers.\n * It needs to stay in memory to keep track of the long-lived connections.\n * It requires a logger at first creation to set everything up.\n */\nexport class McpServerManager {\n\tstatic #instance: McpServerManager;\n\n\tservers: { [sessionId: string]: Server } = {};\n\n\ttransports: {\n\t\t[sessionId: string]: FlushingSSEServerTransport | FlushingStreamableHTTPTransport;\n\t} = {};\n\n\tprivate tools: { [sessionId: string]: Tool[] } = {};\n\n\tprivate resolveFunctions: { [callId: string]: CallableFunction } = {};\n\n\tlogger: Logger;\n\n\tprivate constructor(logger: Logger) {\n\t\tthis.logger = logger;\n\t\tthis.logger.debug('MCP Server created');\n\t}\n\n\tstatic instance(logger: Logger): McpServerManager {\n\t\tif (!McpServerManager.#instance) {\n\t\t\tMcpServerManager.#instance = new McpServerManager(logger);\n\t\t\tlogger.debug('Created singleton MCP manager');\n\t\t}\n\n\t\treturn McpServerManager.#instance;\n\t}\n\n\tasync createServerWithSSETransport(\n\t\tserverName: string,\n\t\tpostUrl: string,\n\t\tresp: CompressionResponse,\n\t): Promise<void> {\n\t\tconst server = new Server(\n\t\t\t{\n\t\t\t\tname: serverName,\n\t\t\t\tversion: '0.1.0',\n\t\t\t},\n\t\t\t{\n\t\t\t\tcapabilities: {\n\t\t\t\t\ttools: {},\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\tconst transport = new FlushingSSEServerTransport(postUrl, resp);\n\n\t\tthis.setUpHandlers(server);\n\n\t\tconst sessionId = transport.sessionId;\n\t\tthis.transports[sessionId] = transport;\n\t\tthis.servers[sessionId] = server;\n\n\t\tresp.on('close', async () => {\n\t\t\tthis.logger.debug(`Deleting transport for ${sessionId}`);\n\t\t\tdelete this.tools[sessionId];\n\t\t\tdelete this.transports[sessionId];\n\t\t\tdelete this.servers[sessionId];\n\t\t});\n\t\tawait server.connect(transport);\n\n\t\t// Make sure we flush the compression middleware, so that it's not waiting for more content to be added to the buffer\n\t\tif (resp.flush) {\n\t\t\tresp.flush();\n\t\t}\n\t}\n\n\tgetSessionId(req: express.Request): string | undefined {\n\t\t// Session ID can be passed either as a query parameter (SSE transport)\n\t\t// or in the header (StreamableHTTP transport).\n\t\treturn (req.query.sessionId ?? req.headers['mcp-session-id']) as string | undefined;\n\t}\n\n\tgetTransport(\n\t\tsessionId: string,\n\t): FlushingSSEServerTransport | FlushingStreamableHTTPTransport | undefined {\n\t\treturn this.transports[sessionId];\n\t}\n\n\tasync createServerWithStreamableHTTPTransport(\n\t\tserverName: string,\n\t\tresp: CompressionResponse,\n\t\treq?: express.Request,\n\t): Promise<void> {\n\t\tconst server = new Server(\n\t\t\t{\n\t\t\t\tname: serverName,\n\t\t\t\tversion: '0.1.0',\n\t\t\t},\n\t\t\t{\n\t\t\t\tcapabilities: {\n\t\t\t\t\ttools: {},\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\tconst transport = new FlushingStreamableHTTPTransport(\n\t\t\t{\n\t\t\t\tsessionIdGenerator: () => randomUUID(),\n\t\t\t\tonsessioninitialized: (sessionId) => {\n\t\t\t\t\tthis.logger.debug(`New session initialized: ${sessionId}`);\n\t\t\t\t\ttransport.onclose = () => {\n\t\t\t\t\t\tthis.logger.debug(`Deleting transport for ${sessionId}`);\n\t\t\t\t\t\tdelete this.tools[sessionId];\n\t\t\t\t\t\tdelete this.transports[sessionId];\n\t\t\t\t\t\tdelete this.servers[sessionId];\n\t\t\t\t\t};\n\t\t\t\t\tthis.transports[sessionId] = transport;\n\t\t\t\t\tthis.servers[sessionId] = server;\n\t\t\t\t},\n\t\t\t},\n\t\t\tresp,\n\t\t);\n\n\t\tthis.setUpHandlers(server);\n\n\t\tawait server.connect(transport);\n\n\t\tawait transport.handleRequest(req as IncomingMessage, resp, req?.body);\n\t\tif (resp.flush) {\n\t\t\tresp.flush();\n\t\t}\n\t}\n\n\tasync handlePostMessage(req: express.Request, resp: CompressionResponse, connectedTools: Tool[]) {\n\t\t// Session ID can be passed either as a query parameter (SSE transport)\n\t\t// or in the header (StreamableHTTP transport).\n\t\tconst sessionId = this.getSessionId(req);\n\t\tconst transport = this.getTransport(sessionId as string);\n\t\tif (sessionId && transport) {\n\t\t\t// We need to add a promise here because the `handlePostMessage` will send something to the\n\t\t\t// MCP Server, that will run in a different context. This means that the return will happen\n\t\t\t// almost immediately, and will lead to marking the sub-node as \"running\" in the final execution\n\t\t\tconst message = jsonParse(req.rawBody.toString());\n\t\t\tconst messageId = getRequestId(message);\n\t\t\t// Use session & message ID if available, otherwise fall back to sessionId\n\t\t\tconst callId = messageId ? `${sessionId}_${messageId}` : sessionId;\n\t\t\tthis.tools[sessionId] = connectedTools;\n\n\t\t\ttry {\n\t\t\t\tawait new Promise(async (resolve) => {\n\t\t\t\t\tthis.resolveFunctions[callId] = resolve;\n\t\t\t\t\tawait transport.handleRequest(req, resp, message as IncomingMessage);\n\t\t\t\t});\n\t\t\t} finally {\n\t\t\t\tdelete this.resolveFunctions[callId];\n\t\t\t}\n\t\t} else {\n\t\t\tthis.logger.warn(`No transport found for session ${sessionId}`);\n\t\t\tresp.status(401).send('No transport found for sessionId');\n\t\t}\n\n\t\tif (resp.flush) {\n\t\t\tresp.flush();\n\t\t}\n\n\t\treturn wasToolCall(req.rawBody.toString());\n\t}\n\n\tasync handleDeleteRequest(req: express.Request, resp: CompressionResponse) {\n\t\tconst sessionId = this.getSessionId(req);\n\n\t\tif (!sessionId) {\n\t\t\tresp.status(400).send('No sessionId provided');\n\t\t\treturn;\n\t\t}\n\n\t\tconst transport = this.getTransport(sessionId);\n\n\t\tif (transport) {\n\t\t\tif (transport instanceof FlushingStreamableHTTPTransport) {\n\t\t\t\tawait transport.handleRequest(req, resp);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// For SSE transport, we don't support DELETE requests\n\t\t\t\tresp.status(405).send('Method Not Allowed');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tresp.status(404).send('Session not found');\n\t}\n\n\tsetUpHandlers(server: Server) {\n\t\tserver.setRequestHandler(\n\t\t\tListToolsRequestSchema,\n\t\t\tasync (_, extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => {\n\t\t\t\tif (!extra.sessionId) {\n\t\t\t\t\tthrow new OperationalError('Require a sessionId for the listing of tools');\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\ttools: this.tools[extra.sessionId].map((tool) => {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tname: tool.name,\n\t\t\t\t\t\t\tdescription: tool.description,\n\t\t\t\t\t\t\t// Allow additional properties on tool call input\n\t\t\t\t\t\t\tinputSchema: zodToJsonSchema(tool.schema, { removeAdditionalStrategy: 'strict' }),\n\t\t\t\t\t\t};\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t},\n\t\t);\n\n\t\tserver.setRequestHandler(\n\t\t\tCallToolRequestSchema,\n\t\t\tasync (request, extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => {\n\t\t\t\tif (!request.params?.name || !request.params?.arguments) {\n\t\t\t\t\tthrow new OperationalError('Require a name and arguments for the tool call');\n\t\t\t\t}\n\t\t\t\tif (!extra.sessionId) {\n\t\t\t\t\tthrow new OperationalError('Require a sessionId for the tool call');\n\t\t\t\t}\n\n\t\t\t\tconst callId = extra.requestId ? `${extra.sessionId}_${extra.requestId}` : extra.sessionId;\n\n\t\t\t\tconst requestedTool: Tool | undefined = this.tools[extra.sessionId].find(\n\t\t\t\t\t(tool) => tool.name === request.params.name,\n\t\t\t\t);\n\t\t\t\tif (!requestedTool) {\n\t\t\t\t\tthrow new OperationalError('Tool not found');\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await requestedTool.invoke(request.params.arguments);\n\t\t\t\t\tif (this.resolveFunctions[callId]) {\n\t\t\t\t\t\tthis.resolveFunctions[callId]();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.logger.warn(`No resolve function found for ${callId}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.logger.debug(`Got request for ${requestedTool.name}, and executed it.`);\n\n\t\t\t\t\tif (typeof result === 'object') {\n\t\t\t\t\t\treturn { content: [{ type: 'text', text: JSON.stringify(result) }] };\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\treturn { content: [{ type: 'text', text: result }] };\n\t\t\t\t\t}\n\t\t\t\t\treturn { content: [{ type: 'text', text: String(result) }] };\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logger.error(`Error while executing Tool ${requestedTool.name}: ${error}`);\n\t\t\t\t\treturn { isError: true, content: [{ type: 'text', text: `Error: ${error.message}` }] };\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\tserver.onclose = () => {\n\t\t\tthis.logger.debug('Closing MCP Server');\n\t\t};\n\t\tserver.onerror = (error: unknown) => {\n\t\t\tthis.logger.error(`MCP Error: ${error}`);\n\t\t};\n\t}\n}\n"],"mappings":"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","names":[]}