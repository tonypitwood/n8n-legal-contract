{"version":3,"sources":["../../../../nodes/tools/ToolHttpRequest/utils.ts"],"sourcesContent":["import { Readability } from '@mozilla/readability';\nimport * as cheerio from 'cheerio';\nimport { convert } from 'html-to-text';\nimport { JSDOM } from 'jsdom';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\nimport unset from 'lodash/unset';\nimport { getOAuth2AdditionalParameters } from 'n8n-nodes-base/dist/nodes/HttpRequest/GenericFunctions';\nimport type {\n\tIDataObject,\n\tIHttpRequestOptions,\n\tIRequestOptionsSimplified,\n\tExecutionError,\n\tNodeApiError,\n\tISupplyDataFunctions,\n} from 'n8n-workflow';\nimport { NodeConnectionTypes, NodeOperationError, jsonParse } from 'n8n-workflow';\nimport { z } from 'zod';\n\nimport type {\n\tParameterInputType,\n\tParametersValues,\n\tPlaceholderDefinition,\n\tParametersValues as RawParametersValues,\n\tSendIn,\n\tToolParameter,\n} from './interfaces';\nimport type { DynamicZodObject } from '../../../types/zod.types';\n\nconst genericCredentialRequest = async (ctx: ISupplyDataFunctions, itemIndex: number) => {\n\tconst genericType = ctx.getNodeParameter('genericAuthType', itemIndex) as string;\n\n\tif (genericType === 'httpBasicAuth' || genericType === 'httpDigestAuth') {\n\t\tconst basicAuth = await ctx.getCredentials('httpBasicAuth', itemIndex);\n\t\tconst sendImmediately = genericType === 'httpDigestAuth' ? false : undefined;\n\n\t\treturn async (options: IHttpRequestOptions) => {\n\t\t\toptions.auth = {\n\t\t\t\tusername: basicAuth.user as string,\n\t\t\t\tpassword: basicAuth.password as string,\n\t\t\t\tsendImmediately,\n\t\t\t};\n\t\t\treturn await ctx.helpers.httpRequest(options);\n\t\t};\n\t}\n\n\tif (genericType === 'httpHeaderAuth') {\n\t\tconst headerAuth = await ctx.getCredentials('httpHeaderAuth', itemIndex);\n\n\t\treturn async (options: IHttpRequestOptions) => {\n\t\t\tif (!options.headers) options.headers = {};\n\t\t\toptions.headers[headerAuth.name as string] = headerAuth.value;\n\t\t\treturn await ctx.helpers.httpRequest(options);\n\t\t};\n\t}\n\n\tif (genericType === 'httpQueryAuth') {\n\t\tconst queryAuth = await ctx.getCredentials('httpQueryAuth', itemIndex);\n\n\t\treturn async (options: IHttpRequestOptions) => {\n\t\t\tif (!options.qs) options.qs = {};\n\t\t\toptions.qs[queryAuth.name as string] = queryAuth.value;\n\t\t\treturn await ctx.helpers.httpRequest(options);\n\t\t};\n\t}\n\n\tif (genericType === 'httpCustomAuth') {\n\t\tconst customAuth = await ctx.getCredentials('httpCustomAuth', itemIndex);\n\n\t\treturn async (options: IHttpRequestOptions) => {\n\t\t\tconst auth = jsonParse<IRequestOptionsSimplified>((customAuth.json as string) || '{}', {\n\t\t\t\terrorMessage: 'Invalid Custom Auth JSON',\n\t\t\t});\n\t\t\tif (auth.headers) {\n\t\t\t\toptions.headers = { ...options.headers, ...auth.headers };\n\t\t\t}\n\t\t\tif (auth.body) {\n\t\t\t\toptions.body = { ...(options.body as IDataObject), ...auth.body };\n\t\t\t}\n\t\t\tif (auth.qs) {\n\t\t\t\toptions.qs = { ...options.qs, ...auth.qs };\n\t\t\t}\n\t\t\treturn await ctx.helpers.httpRequest(options);\n\t\t};\n\t}\n\n\tif (genericType === 'oAuth1Api') {\n\t\treturn async (options: IHttpRequestOptions) => {\n\t\t\treturn await ctx.helpers.requestOAuth1.call(ctx, 'oAuth1Api', options);\n\t\t};\n\t}\n\n\tif (genericType === 'oAuth2Api') {\n\t\treturn async (options: IHttpRequestOptions) => {\n\t\t\treturn await ctx.helpers.requestOAuth2.call(ctx, 'oAuth2Api', options, {\n\t\t\t\ttokenType: 'Bearer',\n\t\t\t});\n\t\t};\n\t}\n\n\tthrow new NodeOperationError(ctx.getNode(), `The type ${genericType} is not supported`, {\n\t\titemIndex,\n\t});\n};\n\nconst predefinedCredentialRequest = async (ctx: ISupplyDataFunctions, itemIndex: number) => {\n\tconst predefinedType = ctx.getNodeParameter('nodeCredentialType', itemIndex) as string;\n\tconst additionalOptions = getOAuth2AdditionalParameters(predefinedType);\n\n\treturn async (options: IHttpRequestOptions) => {\n\t\treturn await ctx.helpers.httpRequestWithAuthentication.call(\n\t\t\tctx,\n\t\t\tpredefinedType,\n\t\t\toptions,\n\t\t\tadditionalOptions && { oauth2: additionalOptions },\n\t\t);\n\t};\n};\n\nexport const configureHttpRequestFunction = async (\n\tctx: ISupplyDataFunctions,\n\tcredentialsType: 'predefinedCredentialType' | 'genericCredentialType' | 'none',\n\titemIndex: number,\n) => {\n\tswitch (credentialsType) {\n\t\tcase 'genericCredentialType':\n\t\t\treturn await genericCredentialRequest(ctx, itemIndex);\n\t\tcase 'predefinedCredentialType':\n\t\t\treturn await predefinedCredentialRequest(ctx, itemIndex);\n\t\tdefault:\n\t\t\treturn async (options: IHttpRequestOptions) => {\n\t\t\t\treturn await ctx.helpers.httpRequest(options);\n\t\t\t};\n\t}\n};\n\nconst defaultOptimizer = <T>(response: T) => {\n\tif (typeof response === 'string') {\n\t\treturn response;\n\t}\n\tif (typeof response === 'object') {\n\t\treturn JSON.stringify(response, null, 2);\n\t}\n\n\treturn String(response);\n};\n\nfunction isBinary(data: unknown) {\n\t// Check if data is a Buffer\n\tif (Buffer.isBuffer(data)) {\n\t\treturn true;\n\t}\n\n\t// If data is a string, assume it's text unless it contains null characters.\n\tif (typeof data === 'string') {\n\t\t// If the string contains a null character, it's likely binary.\n\t\tif (data.includes('\\0')) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// For any other type, assume it's not binary.\n\treturn false;\n}\n\nconst htmlOptimizer = (ctx: ISupplyDataFunctions, itemIndex: number, maxLength: number) => {\n\tconst cssSelector = ctx.getNodeParameter('cssSelector', itemIndex, '') as string;\n\tconst onlyContent = ctx.getNodeParameter('onlyContent', itemIndex, false) as boolean;\n\tlet elementsToOmit: string[] = [];\n\n\tif (onlyContent) {\n\t\tconst elementsToOmitUi = ctx.getNodeParameter('elementsToOmit', itemIndex, '') as\n\t\t\t| string\n\t\t\t| string[];\n\n\t\tif (typeof elementsToOmitUi === 'string') {\n\t\t\telementsToOmit = elementsToOmitUi\n\t\t\t\t.split(',')\n\t\t\t\t.filter((s) => s)\n\t\t\t\t.map((s) => s.trim());\n\t\t}\n\t}\n\n\treturn <T>(response: T) => {\n\t\tif (typeof response !== 'string') {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tctx.getNode(),\n\t\t\t\t`The response type must be a string. Received: ${typeof response}`,\n\t\t\t\t{ itemIndex },\n\t\t\t);\n\t\t}\n\t\tconst returnData: string[] = [];\n\n\t\tconst html = cheerio.load(response);\n\t\tconst htmlElements = html(cssSelector);\n\n\t\thtmlElements.each((_, el) => {\n\t\t\tlet value = html(el).html() || '';\n\n\t\t\tif (onlyContent) {\n\t\t\t\tlet htmlToTextOptions;\n\n\t\t\t\tif (elementsToOmit?.length) {\n\t\t\t\t\thtmlToTextOptions = {\n\t\t\t\t\t\tselectors: elementsToOmit.map((selector) => ({\n\t\t\t\t\t\t\tselector,\n\t\t\t\t\t\t\tformat: 'skip',\n\t\t\t\t\t\t})),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tvalue = convert(value, htmlToTextOptions);\n\t\t\t}\n\n\t\t\tvalue = value\n\t\t\t\t.trim()\n\t\t\t\t.replace(/^\\s+|\\s+$/g, '')\n\t\t\t\t.replace(/(\\r\\n|\\n|\\r)/gm, '')\n\t\t\t\t.replace(/\\s+/g, ' ');\n\n\t\t\treturnData.push(value);\n\t\t});\n\n\t\tconst text = JSON.stringify(returnData, null, 2);\n\n\t\tif (maxLength > 0 && text.length > maxLength) {\n\t\t\treturn text.substring(0, maxLength);\n\t\t}\n\n\t\treturn text;\n\t};\n};\n\nconst textOptimizer = (ctx: ISupplyDataFunctions, itemIndex: number, maxLength: number) => {\n\treturn (response: string | IDataObject) => {\n\t\tif (typeof response === 'object') {\n\t\t\ttry {\n\t\t\t\tresponse = JSON.stringify(response, null, 2);\n\t\t\t} catch (error) {}\n\t\t}\n\n\t\tif (typeof response !== 'string') {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tctx.getNode(),\n\t\t\t\t`The response type must be a string. Received: ${typeof response}`,\n\t\t\t\t{ itemIndex },\n\t\t\t);\n\t\t}\n\n\t\tconst dom = new JSDOM(response);\n\t\tconst article = new Readability(dom.window.document, {\n\t\t\tkeepClasses: true,\n\t\t}).parse();\n\n\t\tconst text = article?.textContent || '';\n\n\t\tif (maxLength > 0 && text.length > maxLength) {\n\t\t\treturn text.substring(0, maxLength);\n\t\t}\n\n\t\treturn text;\n\t};\n};\n\nconst jsonOptimizer = (ctx: ISupplyDataFunctions, itemIndex: number) => {\n\treturn (response: string): string => {\n\t\tlet responseData: IDataObject | IDataObject[] | string = response;\n\n\t\tif (typeof responseData === 'string') {\n\t\t\tresponseData = jsonParse(response);\n\t\t}\n\n\t\tif (typeof responseData !== 'object' || !responseData) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tctx.getNode(),\n\t\t\t\t'The response type must be an object or an array of objects',\n\t\t\t\t{ itemIndex },\n\t\t\t);\n\t\t}\n\n\t\tconst dataField = ctx.getNodeParameter('dataField', itemIndex, '') as string;\n\t\tlet returnData: IDataObject[] = [];\n\n\t\tif (!Array.isArray(responseData)) {\n\t\t\tif (dataField) {\n\t\t\t\tconst data = responseData[dataField] as IDataObject | IDataObject[];\n\t\t\t\tif (Array.isArray(data)) {\n\t\t\t\t\tresponseData = data;\n\t\t\t\t} else {\n\t\t\t\t\tresponseData = [data];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresponseData = [responseData];\n\t\t\t}\n\t\t} else {\n\t\t\tif (dataField) {\n\t\t\t\tresponseData = responseData.map((data) => data[dataField]) as IDataObject[];\n\t\t\t}\n\t\t}\n\n\t\tconst fieldsToInclude = ctx.getNodeParameter('fieldsToInclude', itemIndex, 'all') as\n\t\t\t| 'all'\n\t\t\t| 'selected'\n\t\t\t| 'except';\n\n\t\tlet fields: string | string[] = [];\n\n\t\tif (fieldsToInclude !== 'all') {\n\t\t\tfields = ctx.getNodeParameter('fields', itemIndex, []) as string[] | string;\n\n\t\t\tif (typeof fields === 'string') {\n\t\t\t\tfields = fields.split(',').map((field) => field.trim());\n\t\t\t}\n\t\t} else {\n\t\t\treturnData = responseData;\n\t\t}\n\n\t\tif (fieldsToInclude === 'selected') {\n\t\t\tfor (const item of responseData) {\n\t\t\t\tconst newItem: IDataObject = {};\n\n\t\t\t\tfor (const field of fields) {\n\t\t\t\t\tset(newItem, field, get(item, field));\n\t\t\t\t}\n\n\t\t\t\treturnData.push(newItem);\n\t\t\t}\n\t\t}\n\n\t\tif (fieldsToInclude === 'except') {\n\t\t\tfor (const item of responseData) {\n\t\t\t\tfor (const field of fields) {\n\t\t\t\t\tunset(item, field);\n\t\t\t\t}\n\n\t\t\t\treturnData.push(item);\n\t\t\t}\n\t\t}\n\n\t\treturn JSON.stringify(returnData, null, 2);\n\t};\n};\n\nexport const configureResponseOptimizer = (ctx: ISupplyDataFunctions, itemIndex: number) => {\n\tconst optimizeResponse = ctx.getNodeParameter('optimizeResponse', itemIndex, false) as boolean;\n\n\tif (optimizeResponse) {\n\t\tconst responseType = ctx.getNodeParameter('responseType', itemIndex) as\n\t\t\t| 'json'\n\t\t\t| 'text'\n\t\t\t| 'html';\n\n\t\tlet maxLength = 0;\n\t\tconst truncateResponse = ctx.getNodeParameter('truncateResponse', itemIndex, false) as boolean;\n\n\t\tif (truncateResponse) {\n\t\t\tmaxLength = ctx.getNodeParameter('maxLength', itemIndex, 0) as number;\n\t\t}\n\n\t\tswitch (responseType) {\n\t\t\tcase 'html':\n\t\t\t\treturn htmlOptimizer(ctx, itemIndex, maxLength);\n\t\t\tcase 'text':\n\t\t\t\treturn textOptimizer(ctx, itemIndex, maxLength);\n\t\t\tcase 'json':\n\t\t\t\treturn jsonOptimizer(ctx, itemIndex);\n\t\t}\n\t}\n\n\treturn defaultOptimizer;\n};\n\nconst extractPlaceholders = (text: string): string[] => {\n\tconst placeholder = /(\\{[a-zA-Z0-9_-]+\\})/g;\n\tconst returnData: string[] = [];\n\n\tconst matches = text.matchAll(placeholder);\n\n\tfor (const match of matches) {\n\t\treturnData.push(match[0].replace(/{|}/g, ''));\n\t}\n\n\treturn returnData;\n};\n\nexport const extractParametersFromText = (\n\tplaceholders: PlaceholderDefinition[],\n\ttext: string,\n\tsendIn: SendIn,\n\tkey?: string,\n): ToolParameter[] => {\n\tif (typeof text !== 'string') return [];\n\n\tconst parameters = extractPlaceholders(text);\n\n\tif (parameters.length) {\n\t\tconst inputParameters = prepareParameters(\n\t\t\tparameters.map((name) => ({\n\t\t\t\tname,\n\t\t\t\tvalueProvider: 'modelRequired',\n\t\t\t})),\n\t\t\tplaceholders,\n\t\t\t'keypair',\n\t\t\tsendIn,\n\t\t\t'',\n\t\t);\n\n\t\treturn key\n\t\t\t? inputParameters.parameters.map((p) => ({ ...p, key }))\n\t\t\t: inputParameters.parameters;\n\t}\n\n\treturn [];\n};\n\nfunction prepareParameters(\n\trawParameters: RawParametersValues,\n\tplaceholders: PlaceholderDefinition[],\n\tparametersInputType: 'model' | 'keypair' | 'json',\n\tsendIn: SendIn,\n\tmodelInputDescription: string,\n\tjsonWithPlaceholders?: string,\n): { parameters: ToolParameter[]; values: IDataObject } {\n\tconst parameters: ToolParameter[] = [];\n\tconst values: IDataObject = {};\n\n\tif (parametersInputType === 'model') {\n\t\treturn {\n\t\t\tparameters: [\n\t\t\t\t{\n\t\t\t\t\tname: sendIn,\n\t\t\t\t\trequired: true,\n\t\t\t\t\ttype: 'json',\n\t\t\t\t\tdescription: modelInputDescription,\n\t\t\t\t\tsendIn,\n\t\t\t\t},\n\t\t\t],\n\t\t\tvalues: {},\n\t\t};\n\t}\n\n\tif (parametersInputType === 'keypair') {\n\t\tfor (const entry of rawParameters) {\n\t\t\tif (entry.valueProvider.includes('model')) {\n\t\t\t\tconst placeholder = placeholders.find((p) => p.name === entry.name);\n\n\t\t\t\tconst parameter: ToolParameter = {\n\t\t\t\t\tname: entry.name,\n\t\t\t\t\trequired: entry.valueProvider === 'modelRequired',\n\t\t\t\t\tsendIn,\n\t\t\t\t};\n\n\t\t\t\tif (placeholder) {\n\t\t\t\t\tparameter.type = placeholder.type;\n\t\t\t\t\tparameter.description = placeholder.description;\n\t\t\t\t}\n\n\t\t\t\tparameters.push(parameter);\n\t\t\t} else if (entry.value) {\n\t\t\t\t// if value has placeholders push them to parameters\n\t\t\t\tparameters.push(\n\t\t\t\t\t...extractParametersFromText(placeholders, entry.value, sendIn, entry.name),\n\t\t\t\t);\n\t\t\t\tvalues[entry.name] = entry.value; //push to user provided values\n\t\t\t}\n\t\t}\n\t}\n\n\tif (parametersInputType === 'json' && jsonWithPlaceholders) {\n\t\tparameters.push(\n\t\t\t...extractParametersFromText(placeholders, jsonWithPlaceholders, sendIn, `${sendIn + 'Raw'}`),\n\t\t);\n\t}\n\n\treturn {\n\t\tparameters,\n\t\tvalues,\n\t};\n}\n\nconst MODEL_INPUT_DESCRIPTION = {\n\tqs: 'Query parameters for request as key value pairs',\n\theaders: 'Headers parameters for request as key value pairs',\n\tbody: 'Body parameters for request as key value pairs',\n};\n\nexport const updateParametersAndOptions = (options: {\n\tctx: ISupplyDataFunctions;\n\titemIndex: number;\n\ttoolParameters: ToolParameter[];\n\tplaceholdersDefinitions: PlaceholderDefinition[];\n\trequestOptions: IHttpRequestOptions;\n\trawRequestOptions: { [key: string]: string };\n\trequestOptionsProperty: 'headers' | 'qs' | 'body';\n\tinputTypePropertyName: string;\n\tjsonPropertyName: string;\n\tparametersPropertyName: string;\n}) => {\n\tconst {\n\t\tctx,\n\t\titemIndex,\n\t\ttoolParameters,\n\t\tplaceholdersDefinitions,\n\t\trequestOptions,\n\t\trawRequestOptions,\n\t\trequestOptionsProperty,\n\t\tinputTypePropertyName,\n\t\tjsonPropertyName,\n\t\tparametersPropertyName,\n\t} = options;\n\n\tconst inputType = ctx.getNodeParameter(\n\t\tinputTypePropertyName,\n\t\titemIndex,\n\t\t'keypair',\n\t) as ParameterInputType;\n\n\tlet parametersValues: ParametersValues = [];\n\n\tif (inputType === 'json') {\n\t\trawRequestOptions[requestOptionsProperty] = ctx.getNodeParameter(\n\t\t\tjsonPropertyName,\n\t\t\titemIndex,\n\t\t\t'',\n\t\t) as string;\n\t} else {\n\t\tparametersValues = ctx.getNodeParameter(\n\t\t\tparametersPropertyName,\n\t\t\titemIndex,\n\t\t\t[],\n\t\t) as ParametersValues;\n\t}\n\n\tconst inputParameters = prepareParameters(\n\t\tparametersValues,\n\t\tplaceholdersDefinitions,\n\t\tinputType,\n\t\trequestOptionsProperty,\n\t\tMODEL_INPUT_DESCRIPTION[requestOptionsProperty],\n\t\trawRequestOptions[requestOptionsProperty],\n\t);\n\n\ttoolParameters.push(...inputParameters.parameters);\n\n\trequestOptions[requestOptionsProperty] = {\n\t\t...(requestOptions[requestOptionsProperty] as IDataObject),\n\t\t...inputParameters.values,\n\t};\n};\n\nconst getParametersDescription = (parameters: ToolParameter[]) =>\n\tparameters\n\t\t.map(\n\t\t\t(p) =>\n\t\t\t\t`${p.name}: (description: ${p.description ?? ''}, type: ${p.type ?? 'string'}, required: ${!!p.required})`,\n\t\t)\n\t\t.join(',\\n ');\n\nexport const prepareToolDescription = (\n\ttoolDescription: string,\n\ttoolParameters: ToolParameter[],\n) => {\n\tlet description = `${toolDescription}`;\n\n\tif (toolParameters.length) {\n\t\tdescription += `\n\tTool expects valid stringified JSON object with ${toolParameters.length} properties.\n\tProperty names with description, type and required status:\n\t${getParametersDescription(toolParameters)}\n\tALL parameters marked as required must be provided`;\n\t}\n\n\treturn description;\n};\n\nexport const configureToolFunction = (\n\tctx: ISupplyDataFunctions,\n\titemIndex: number,\n\ttoolParameters: ToolParameter[],\n\trequestOptions: IHttpRequestOptions,\n\trawRequestOptions: { [key: string]: string },\n\thttpRequest: (options: IHttpRequestOptions) => Promise<any>,\n\toptimizeResponse: (response: string) => string,\n) => {\n\treturn async (query: string | IDataObject): Promise<string> => {\n\t\tconst { index } = ctx.addInputData(NodeConnectionTypes.AiTool, [[{ json: { query } }]]);\n\n\t\t// Clone options and rawRequestOptions to avoid mutating the original objects\n\t\tconst options: IHttpRequestOptions | null = structuredClone(requestOptions);\n\t\tconst clonedRawRequestOptions: { [key: string]: string } = structuredClone(rawRequestOptions);\n\t\tlet fullResponse: any;\n\t\tlet response: string = '';\n\t\tlet executionError: Error | undefined = undefined;\n\n\t\tif (!toolParameters.length) {\n\t\t\tquery = '{}';\n\t\t}\n\n\t\ttry {\n\t\t\tif (query) {\n\t\t\t\tlet dataFromModel;\n\n\t\t\t\tif (typeof query === 'string') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdataFromModel = jsonParse<IDataObject>(query);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (toolParameters.length === 1) {\n\t\t\t\t\t\t\tdataFromModel = { [toolParameters[0].name]: query };\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\t\t\tctx.getNode(),\n\t\t\t\t\t\t\t\t`Input is not a valid JSON: ${error.message}`,\n\t\t\t\t\t\t\t\t{ itemIndex },\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdataFromModel = query;\n\t\t\t\t}\n\n\t\t\t\tfor (const parameter of toolParameters) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tparameter.required &&\n\t\t\t\t\t\t(dataFromModel[parameter.name] === undefined || dataFromModel[parameter.name] === null)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\t\tctx.getNode(),\n\t\t\t\t\t\t\t`Model did not provide parameter '${parameter.name}' which is required and must be present in the input`,\n\t\t\t\t\t\t\t{ itemIndex },\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const parameter of toolParameters) {\n\t\t\t\t\tlet argument = dataFromModel[parameter.name];\n\n\t\t\t\t\tif (\n\t\t\t\t\t\targument &&\n\t\t\t\t\t\tparameter.type === 'json' &&\n\t\t\t\t\t\t!['qsRaw', 'headersRaw', 'bodyRaw'].includes(parameter.key ?? '') &&\n\t\t\t\t\t\ttypeof argument !== 'object'\n\t\t\t\t\t) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\targument = jsonParse(String(argument));\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\t\t\tctx.getNode(),\n\t\t\t\t\t\t\t\t`Parameter ${parameter.name} is not a valid JSON: ${error.message}`,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parameter.sendIn === 'path') {\n\t\t\t\t\t\targument = String(argument);\n\n\t\t\t\t\t\t//remove \" or ' from start or end\n\t\t\t\t\t\targument = argument.replace(/^['\"]+|['\"]+$/g, '');\n\n\t\t\t\t\t\toptions.url = options.url.replace(`{${parameter.name}}`, argument);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parameter.sendIn === parameter.name) {\n\t\t\t\t\t\tset(options, [parameter.sendIn], argument);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (['qsRaw', 'headersRaw', 'bodyRaw'].includes(parameter.key ?? '')) {\n\t\t\t\t\t\t//enclose string in quotes as user and model could omit them\n\t\t\t\t\t\tif (parameter.type === 'string') {\n\t\t\t\t\t\t\targument = String(argument);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!argument.startsWith('\"') &&\n\t\t\t\t\t\t\t\t!clonedRawRequestOptions[parameter.sendIn].includes(`\"{${parameter.name}}\"`)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\targument = `\"${argument}\"`;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof argument === 'object') {\n\t\t\t\t\t\t\targument = JSON.stringify(argument);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclonedRawRequestOptions[parameter.sendIn] = clonedRawRequestOptions[\n\t\t\t\t\t\t\tparameter.sendIn\n\t\t\t\t\t\t].replace(`{${parameter.name}}`, String(argument));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parameter.key) {\n\t\t\t\t\t\tlet requestOptionsValue = get(options, [parameter.sendIn, parameter.key]);\n\n\t\t\t\t\t\tif (typeof requestOptionsValue === 'string') {\n\t\t\t\t\t\t\trequestOptionsValue = requestOptionsValue.replace(\n\t\t\t\t\t\t\t\t`{${parameter.name}}`,\n\t\t\t\t\t\t\t\tString(argument),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tset(options, [parameter.sendIn, parameter.key], requestOptionsValue);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tset(options, [parameter.sendIn, parameter.name], argument);\n\t\t\t\t}\n\n\t\t\t\tfor (const [key, value] of Object.entries(clonedRawRequestOptions)) {\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tlet parsedValue;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tparsedValue = jsonParse<IDataObject>(value);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tlet recoveredData = '';\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\trecoveredData = value\n\t\t\t\t\t\t\t\t\t.replace(/'/g, '\"') // Replace single quotes with double quotes\n\t\t\t\t\t\t\t\t\t.replace(/(['\"])?([a-zA-Z0-9_]+)(['\"])?:/g, '\"$2\":') // Wrap keys in double quotes\n\t\t\t\t\t\t\t\t\t.replace(/,\\s*([\\]}])/g, '$1') // Remove trailing commas from objects\n\t\t\t\t\t\t\t\t\t.replace(/,+$/, ''); // Remove trailing comma\n\t\t\t\t\t\t\t\tparsedValue = jsonParse<IDataObject>(recoveredData);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\t\t\t\tctx.getNode(),\n\t\t\t\t\t\t\t\t\t`Could not replace placeholders in ${key}: ${error.message}`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptions[key as 'qs' | 'headers' | 'body'] = parsedValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (options) {\n\t\t\t\toptions.url = encodeURI(options.url);\n\n\t\t\t\tif (options.headers && !Object.keys(options.headers).length) {\n\t\t\t\t\tdelete options.headers;\n\t\t\t\t}\n\t\t\t\tif (options.qs && !Object.keys(options.qs).length) {\n\t\t\t\t\tdelete options.qs;\n\t\t\t\t}\n\t\t\t\tif (options.body && !Object.keys(options.body).length) {\n\t\t\t\t\tdelete options.body;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconst errorMessage = 'Input provided by model is not valid';\n\n\t\t\tif (error instanceof NodeOperationError) {\n\t\t\t\texecutionError = error;\n\t\t\t} else {\n\t\t\t\texecutionError = new NodeOperationError(ctx.getNode(), errorMessage, {\n\t\t\t\t\titemIndex,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tresponse = errorMessage;\n\t\t}\n\n\t\tif (options) {\n\t\t\ttry {\n\t\t\t\tfullResponse = await httpRequest(options);\n\t\t\t} catch (error) {\n\t\t\t\tconst httpCode = (error as NodeApiError).httpCode;\n\t\t\t\tresponse = `${httpCode ? `HTTP ${httpCode} ` : ''}There was an error: \"${error.message}\"`;\n\t\t\t}\n\n\t\t\tif (!response) {\n\t\t\t\ttry {\n\t\t\t\t\t// Check if the response is binary data\n\t\t\t\t\tif (fullResponse.body && isBinary(fullResponse.body)) {\n\t\t\t\t\t\tthrow new NodeOperationError(ctx.getNode(), 'Binary data is not supported');\n\t\t\t\t\t}\n\n\t\t\t\t\tresponse = optimizeResponse(fullResponse.body ?? fullResponse);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tresponse = `There was an error: \"${error.message}\"`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof response !== 'string') {\n\t\t\texecutionError = new NodeOperationError(ctx.getNode(), 'Wrong output type returned', {\n\t\t\t\tdescription: `The response property should be a string, but it is an ${typeof response}`,\n\t\t\t});\n\t\t\tresponse = `There was an error: \"${executionError.message}\"`;\n\t\t}\n\n\t\tif (executionError) {\n\t\t\tvoid ctx.addOutputData(NodeConnectionTypes.AiTool, index, executionError as ExecutionError);\n\t\t} else {\n\t\t\tvoid ctx.addOutputData(NodeConnectionTypes.AiTool, index, [[{ json: { response } }]]);\n\t\t}\n\n\t\treturn response;\n\t};\n};\n\nfunction makeParameterZodSchema(parameter: ToolParameter) {\n\tlet schema: z.ZodTypeAny;\n\n\tif (parameter.type === 'string') {\n\t\tschema = z.string();\n\t} else if (parameter.type === 'number') {\n\t\tschema = z.number();\n\t} else if (parameter.type === 'boolean') {\n\t\tschema = z.boolean();\n\t} else if (parameter.type === 'json') {\n\t\tschema = z.record(z.any());\n\t} else {\n\t\tschema = z.string();\n\t}\n\n\tif (!parameter.required) {\n\t\tschema = schema.optional();\n\t}\n\n\tif (parameter.description) {\n\t\tschema = schema.describe(parameter.description);\n\t}\n\n\treturn schema;\n}\n\nexport function makeToolInputSchema(parameters: ToolParameter[]): DynamicZodObject {\n\tconst schemaEntries = parameters.map((parameter) => [\n\t\tparameter.name,\n\t\tmakeParameterZodSchema(parameter),\n\t]);\n\n\treturn z.object(Object.fromEntries(schemaEntries));\n}\n"],"mappings":"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","names":["set","get","unset"]}