{"version":3,"sources":["../../../../../../nodes/tools/ToolWorkflow/v2/utils/WorkflowToolService.ts"],"sourcesContent":["import type { CallbackManagerForToolRun } from '@langchain/core/callbacks/manager';\nimport { DynamicStructuredTool, DynamicTool } from '@langchain/core/tools';\nimport isArray from 'lodash/isArray';\nimport isObject from 'lodash/isObject';\nimport type { SetField, SetNodeOptions } from 'n8n-nodes-base/dist/nodes/Set/v2/helpers/interfaces';\nimport * as manual from 'n8n-nodes-base/dist/nodes/Set/v2/manual.mode';\nimport { getCurrentWorkflowInputData } from 'n8n-nodes-base/dist/utils/workflowInputsResourceMapping/GenericFunctions';\nimport type {\n\tExecuteWorkflowData,\n\tExecutionError,\n\tFromAIArgument,\n\tIDataObject,\n\tIExecuteFunctions,\n\tIExecuteWorkflowInfo,\n\tINodeExecutionData,\n\tINodeParameterResourceLocator,\n\tISupplyDataFunctions,\n\tITaskMetadata,\n\tIWorkflowBase,\n\tIWorkflowDataProxyData,\n\tResourceMapperValue,\n} from 'n8n-workflow';\nimport {\n\tgenerateZodSchema,\n\tjsonParse,\n\tNodeConnectionTypes,\n\tNodeOperationError,\n\tparseErrorMetadata,\n\tsleepWithAbort,\n\ttraverseNodeParameters,\n} from 'n8n-workflow';\nimport { z } from 'zod';\n\nfunction isNodeExecutionData(data: unknown): data is INodeExecutionData[] {\n\treturn isArray(data) && Boolean(data.length) && isObject(data[0]) && 'json' in data[0];\n}\n\n/**\n\tMain class for creating the Workflow tool\n\tProcesses the node parameters and creates AI Agent tool capable of executing n8n workflows\n*/\nexport class WorkflowToolService {\n\t// Determines if we should use input schema when creating the tool\n\tprivate useSchema: boolean;\n\n\t// Sub-workflow id, pulled from referenced sub-workflow\n\tprivate subWorkflowId: string | undefined;\n\n\t// Sub-workflow execution id, will be set after the sub-workflow is executed\n\tprivate subExecutionId: string | undefined;\n\n\tprivate returnAllItems: boolean = false;\n\n\tconstructor(\n\t\tprivate baseContext: ISupplyDataFunctions | IExecuteFunctions,\n\t\toptions?: { returnAllItems: boolean },\n\t) {\n\t\tconst subWorkflowInputs = this.baseContext.getNode().parameters\n\t\t\t.workflowInputs as ResourceMapperValue;\n\t\tthis.useSchema = (subWorkflowInputs?.schema ?? []).length > 0;\n\t\tthis.returnAllItems = options?.returnAllItems ?? false;\n\t}\n\n\t// Creates the tool based on the provided parameters\n\tasync createTool({\n\t\tctx,\n\t\tname,\n\t\tdescription,\n\t\titemIndex,\n\t\tmanualLogging = true,\n\t}: {\n\t\tctx: ISupplyDataFunctions | IExecuteFunctions;\n\t\tname: string;\n\t\tdescription: string;\n\t\titemIndex: number;\n\t\tmanualLogging?: boolean;\n\t}): Promise<DynamicTool | DynamicStructuredTool> {\n\t\t// Handler for the tool execution, will be called when the tool is executed\n\t\t// This function will execute the sub-workflow and return the response\n\t\t// We get the runIndex from the context to handle multiple executions\n\t\t// of the same tool when the tool is used in a loop or in a parallel execution.\n\t\tconst node = ctx.getNode();\n\n\t\tlet runIndex: number = 'getNextRunIndex' in ctx ? ctx.getNextRunIndex() : 0;\n\t\tconst toolHandler = async (\n\t\t\tquery: string | IDataObject,\n\t\t\trunManager?: CallbackManagerForToolRun,\n\t\t): Promise<IDataObject | IDataObject[] | string> => {\n\t\t\tlet maxTries = 1;\n\t\t\tif (node.retryOnFail === true) {\n\t\t\t\tmaxTries = Math.min(5, Math.max(2, node.maxTries ?? 3));\n\t\t\t}\n\n\t\t\tlet waitBetweenTries = 0;\n\t\t\tif (node.retryOnFail === true) {\n\t\t\t\twaitBetweenTries = Math.min(5000, Math.max(0, node.waitBetweenTries ?? 1000));\n\t\t\t}\n\n\t\t\tlet lastError: ExecutionError | undefined;\n\n\t\t\tfor (let tryIndex = 0; tryIndex < maxTries; tryIndex++) {\n\t\t\t\tconst localRunIndex = runIndex++;\n\n\t\t\t\tlet context = this.baseContext;\n\t\t\t\t// We need to clone the context here to handle runIndex correctly\n\t\t\t\t// Otherwise the runIndex will be shared between different executions\n\t\t\t\t// Causing incorrect data to be passed to the sub-workflow and via $fromAI\n\t\t\t\tif ('cloneWith' in this.baseContext) {\n\t\t\t\t\tcontext = this.baseContext.cloneWith({\n\t\t\t\t\t\trunIndex: localRunIndex,\n\t\t\t\t\t\tinputData: [[{ json: { query } }]],\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Get abort signal from context for cancellation support\n\t\t\t\tconst abortSignal = context.getExecutionCancelSignal?.();\n\n\t\t\t\t// Check if execution was cancelled before retry\n\t\t\t\tif (abortSignal?.aborted) {\n\t\t\t\t\treturn 'There was an error: \"Execution was cancelled\"';\n\t\t\t\t}\n\n\t\t\t\tif (tryIndex !== 0) {\n\t\t\t\t\t// Reset error from previous attempt\n\t\t\t\t\tlastError = undefined;\n\t\t\t\t\tif (waitBetweenTries !== 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait sleepWithAbort(waitBetweenTries, abortSignal);\n\t\t\t\t\t\t} catch (abortError) {\n\t\t\t\t\t\t\treturn 'There was an error: \"Execution was cancelled\"';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await this.runFunction(context, query, itemIndex, runManager);\n\n\t\t\t\t\tconst processedResponse = this.handleToolResponse(response);\n\n\t\t\t\t\tlet responseData: INodeExecutionData[];\n\t\t\t\t\tif (isNodeExecutionData(response)) {\n\t\t\t\t\t\tresponseData = response;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst reParsedData = jsonParse<IDataObject>(processedResponse, {\n\t\t\t\t\t\t\tfallbackValue: { response: processedResponse },\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tresponseData = [{ json: reParsedData }];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Once the sub-workflow is executed, add the output data to the context\n\t\t\t\t\t// This will be used to link the sub-workflow execution in the parent workflow\n\t\t\t\t\tlet metadata: ITaskMetadata | undefined;\n\t\t\t\t\tif (this.subExecutionId && this.subWorkflowId) {\n\t\t\t\t\t\tmetadata = {\n\t\t\t\t\t\t\tsubExecution: {\n\t\t\t\t\t\t\t\texecutionId: this.subExecutionId,\n\t\t\t\t\t\t\t\tworkflowId: this.subWorkflowId,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tif (manualLogging) {\n\t\t\t\t\t\tvoid context.addOutputData(\n\t\t\t\t\t\t\tNodeConnectionTypes.AiTool,\n\t\t\t\t\t\t\tlocalRunIndex,\n\t\t\t\t\t\t\t[responseData],\n\t\t\t\t\t\t\tmetadata,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn processedResponse;\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Check if error is due to cancellation\n\t\t\t\t\tif (abortSignal?.aborted) {\n\t\t\t\t\t\treturn 'There was an error: \"Execution was cancelled\"';\n\t\t\t\t\t}\n\n\t\t\t\t\tconst executionError = error as ExecutionError;\n\t\t\t\t\tlastError = executionError;\n\t\t\t\t\tconst errorResponse = `There was an error: \"${executionError.message}\"`;\n\n\t\t\t\t\tif (manualLogging) {\n\t\t\t\t\t\tconst metadata = parseErrorMetadata(error);\n\t\t\t\t\t\tvoid context.addOutputData(\n\t\t\t\t\t\t\tNodeConnectionTypes.AiTool,\n\t\t\t\t\t\t\tlocalRunIndex,\n\t\t\t\t\t\t\texecutionError,\n\t\t\t\t\t\t\tmetadata,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tryIndex === maxTries - 1) {\n\t\t\t\t\t\treturn errorResponse;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn `There was an error: ${lastError?.message ?? 'Unknown error'}`;\n\t\t};\n\n\t\t// Create structured tool if input schema is provided\n\t\treturn this.useSchema\n\t\t\t? await this.createStructuredTool(name, description, toolHandler)\n\t\t\t: new DynamicTool({ name, description, func: toolHandler });\n\t}\n\n\tprivate handleToolResponse(response: unknown): string {\n\t\tif (typeof response === 'number') {\n\t\t\treturn response.toString();\n\t\t}\n\n\t\tif (isNodeExecutionData(response)) {\n\t\t\treturn JSON.stringify(\n\t\t\t\tresponse.map((item) => item.json),\n\t\t\t\tnull,\n\t\t\t\t2,\n\t\t\t);\n\t\t}\n\n\t\tif (isObject(response)) {\n\t\t\treturn JSON.stringify(response, null, 2);\n\t\t}\n\n\t\tif (typeof response !== 'string') {\n\t\t\tthrow new NodeOperationError(this.baseContext.getNode(), 'Wrong output type returned', {\n\t\t\t\tdescription: `The response property should be a string, but it is an ${typeof response}`,\n\t\t\t});\n\t\t}\n\n\t\treturn response;\n\t}\n\n\t/**\n\t * Executes specified sub-workflow with provided inputs\n\t */\n\tprivate async executeSubWorkflow(\n\t\tcontext: ISupplyDataFunctions | IExecuteFunctions,\n\t\tworkflowInfo: IExecuteWorkflowInfo,\n\t\titems: INodeExecutionData[],\n\t\tworkflowProxy: IWorkflowDataProxyData,\n\t\trunManager?: CallbackManagerForToolRun,\n\t): Promise<{ response: string | IDataObject | INodeExecutionData[]; subExecutionId: string }> {\n\t\tlet receivedData: ExecuteWorkflowData;\n\t\ttry {\n\t\t\treceivedData = await context.executeWorkflow(workflowInfo, items, runManager?.getChild(), {\n\t\t\t\tparentExecution: {\n\t\t\t\t\texecutionId: workflowProxy.$execution.id,\n\t\t\t\t\tworkflowId: workflowProxy.$workflow.id,\n\t\t\t\t},\n\t\t\t});\n\t\t\t// Set sub-workflow execution id so it can be used in other places\n\t\t\tthis.subExecutionId = receivedData.executionId;\n\t\t} catch (error) {\n\t\t\tthrow new NodeOperationError(context.getNode(), error as Error);\n\t\t}\n\n\t\tlet response: IDataObject | INodeExecutionData[] | undefined;\n\t\tif (this.returnAllItems) {\n\t\t\tresponse = receivedData?.data?.[0]?.length ? receivedData.data[0] : undefined;\n\t\t} else {\n\t\t\tresponse = receivedData?.data?.[0]?.[0]?.json;\n\t\t}\n\t\tif (response === undefined) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tcontext.getNode(),\n\t\t\t\t'There was an error: \"The workflow did not return a response\"',\n\t\t\t);\n\t\t}\n\n\t\treturn { response, subExecutionId: receivedData.executionId };\n\t}\n\n\t/**\n\t * Gets the sub-workflow info based on the source and executes it.\n\t * This function will be called as part of the tool execution (from the toolHandler)\n\t */\n\tprivate async runFunction(\n\t\tcontext: ISupplyDataFunctions | IExecuteFunctions,\n\t\tquery: string | IDataObject,\n\t\titemIndex: number,\n\t\trunManager?: CallbackManagerForToolRun,\n\t): Promise<string | IDataObject | INodeExecutionData[]> {\n\t\tconst source = context.getNodeParameter('source', itemIndex) as string;\n\t\tconst workflowProxy = context.getWorkflowDataProxy(0);\n\n\t\tconst { workflowInfo } = await this.getSubWorkflowInfo(\n\t\t\tcontext,\n\t\t\tsource,\n\t\t\titemIndex,\n\t\t\tworkflowProxy,\n\t\t);\n\t\tconst rawData = this.prepareRawData(context, query, itemIndex);\n\t\tconst items = await this.prepareWorkflowItems(context, query, itemIndex, rawData);\n\n\t\tthis.subWorkflowId = workflowInfo.id;\n\n\t\tconst { response } = await this.executeSubWorkflow(\n\t\t\tcontext,\n\t\t\tworkflowInfo,\n\t\t\titems,\n\t\t\tworkflowProxy,\n\t\t\trunManager,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets the sub-workflow info based on the source (database or parameter)\n\t */\n\tprivate async getSubWorkflowInfo(\n\t\tcontext: ISupplyDataFunctions | IExecuteFunctions,\n\t\tsource: string,\n\t\titemIndex: number,\n\t\tworkflowProxy: IWorkflowDataProxyData,\n\t): Promise<{\n\t\tworkflowInfo: IExecuteWorkflowInfo;\n\t\tsubWorkflowId: string;\n\t}> {\n\t\tconst workflowInfo: IExecuteWorkflowInfo = {};\n\t\tlet subWorkflowId: string;\n\n\t\tif (source === 'database') {\n\t\t\tconst { value } = context.getNodeParameter(\n\t\t\t\t'workflowId',\n\t\t\t\titemIndex,\n\t\t\t\t{},\n\t\t\t) as INodeParameterResourceLocator;\n\t\t\tworkflowInfo.id = value as string;\n\t\t\tsubWorkflowId = workflowInfo.id;\n\t\t} else if (source === 'parameter') {\n\t\t\tconst workflowJson = context.getNodeParameter('workflowJson', itemIndex) as string;\n\t\t\ttry {\n\t\t\t\tworkflowInfo.code = JSON.parse(workflowJson) as IWorkflowBase;\n\t\t\t\t// subworkflow is same as parent workflow\n\t\t\t\tsubWorkflowId = workflowProxy.$workflow.id;\n\t\t\t} catch (error) {\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tcontext.getNode(),\n\t\t\t\t\t`The provided workflow is not valid JSON: \"${(error as Error).message}\"`,\n\t\t\t\t\t{ itemIndex },\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn { workflowInfo, subWorkflowId: subWorkflowId! };\n\t}\n\n\tprivate prepareRawData(\n\t\tcontext: ISupplyDataFunctions | IExecuteFunctions,\n\t\tquery: string | IDataObject,\n\t\titemIndex: number,\n\t): IDataObject {\n\t\tconst rawData: IDataObject = { query };\n\t\tconst workflowFieldsJson = context.getNodeParameter('fields.values', itemIndex, [], {\n\t\t\trawExpressions: true,\n\t\t}) as SetField[];\n\n\t\t// Copied from Set Node v2\n\t\tfor (const entry of workflowFieldsJson) {\n\t\t\tif (entry.type === 'objectValue' && (entry.objectValue as string).startsWith('=')) {\n\t\t\t\trawData[entry.name] = (entry.objectValue as string).replace(/^=+/, '');\n\t\t\t}\n\t\t}\n\n\t\treturn rawData;\n\t}\n\n\t/**\n\t * Prepares the sub-workflow items for execution\n\t */\n\tprivate async prepareWorkflowItems(\n\t\tcontext: ISupplyDataFunctions | IExecuteFunctions,\n\t\tquery: string | IDataObject,\n\t\titemIndex: number,\n\t\trawData: IDataObject,\n\t): Promise<INodeExecutionData[]> {\n\t\tconst options: SetNodeOptions = { include: 'all' };\n\t\tlet jsonData = typeof query === 'object' ? query : { query };\n\n\t\tif (this.useSchema) {\n\t\t\tconst currentWorkflowInputs = getCurrentWorkflowInputData.call(context);\n\t\t\tjsonData = currentWorkflowInputs[itemIndex].json;\n\t\t}\n\n\t\tconst newItem = await manual.execute.call(\n\t\t\tcontext,\n\t\t\t{ json: jsonData },\n\t\t\titemIndex,\n\t\t\toptions,\n\t\t\trawData,\n\t\t\tcontext.getNode(),\n\t\t);\n\n\t\treturn [newItem] as INodeExecutionData[];\n\t}\n\n\t/**\n\t *  Create structured tool by parsing the sub-workflow input schema\n\t */\n\tprivate async createStructuredTool(\n\t\tname: string,\n\t\tdescription: string,\n\t\tfunc: (\n\t\t\tquery: string | IDataObject,\n\t\t\trunManager?: CallbackManagerForToolRun,\n\t\t) => Promise<string | IDataObject | IDataObject[]>,\n\t): Promise<DynamicStructuredTool | DynamicTool> {\n\t\tconst collectedArguments = await this.extractFromAIParameters();\n\n\t\t// If there are no `fromAI` arguments, fallback to creating a simple tool\n\t\tif (collectedArguments.length === 0) {\n\t\t\treturn new DynamicTool({ name, description, func });\n\t\t}\n\n\t\t// Otherwise, prepare Zod schema  and create a structured tool\n\t\tconst schema = this.createZodSchema(collectedArguments);\n\t\treturn new DynamicStructuredTool({ schema, name, description, func });\n\t}\n\n\tprivate async extractFromAIParameters(): Promise<FromAIArgument[]> {\n\t\tconst collectedArguments: FromAIArgument[] = [];\n\t\ttraverseNodeParameters(this.baseContext.getNode().parameters, collectedArguments);\n\n\t\tconst uniqueArgsMap = new Map<string, FromAIArgument>();\n\t\tfor (const arg of collectedArguments) {\n\t\t\tuniqueArgsMap.set(arg.key, arg);\n\t\t}\n\n\t\treturn Array.from(uniqueArgsMap.values());\n\t}\n\n\tprivate createZodSchema(args: FromAIArgument[]): z.ZodObject<any> {\n\t\tconst schemaObj = args.reduce((acc: Record<string, z.ZodTypeAny>, placeholder) => {\n\t\t\tacc[placeholder.key] = generateZodSchema(placeholder);\n\t\t\treturn acc;\n\t\t}, {});\n\n\t\treturn z.object(schemaObj).required();\n\t}\n}\n"],"mappings":"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","names":["isArray","isObject"]}