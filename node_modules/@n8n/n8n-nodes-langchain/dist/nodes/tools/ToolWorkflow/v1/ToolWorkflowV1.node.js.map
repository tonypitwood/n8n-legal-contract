{"version":3,"sources":["../../../../../nodes/tools/ToolWorkflow/v1/ToolWorkflowV1.node.ts"],"sourcesContent":["import type { CallbackManagerForToolRun } from '@langchain/core/callbacks/manager';\nimport { DynamicStructuredTool, DynamicTool } from '@langchain/core/tools';\nimport type { JSONSchema7 } from 'json-schema';\nimport get from 'lodash/get';\nimport isObject from 'lodash/isObject';\nimport type { SetField, SetNodeOptions } from 'n8n-nodes-base/dist/nodes/Set/v2/helpers/interfaces';\nimport * as manual from 'n8n-nodes-base/dist/nodes/Set/v2/manual.mode';\nimport type {\n\tIExecuteWorkflowInfo,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeDescription,\n\tIWorkflowBase,\n\tISupplyDataFunctions,\n\tSupplyData,\n\tExecutionError,\n\tExecuteWorkflowData,\n\tIDataObject,\n\tINodeParameterResourceLocator,\n\tITaskMetadata,\n\tINodeTypeBaseDescription,\n} from 'n8n-workflow';\nimport { NodeConnectionTypes, NodeOperationError, jsonParse } from 'n8n-workflow';\n\nimport { versionDescription } from './versionDescription';\nimport type { DynamicZodObject } from '../../../../types/zod.types';\nimport { convertJsonSchemaToZod, generateSchemaFromExample } from '../../../../utils/schemaParsing';\n\nexport class ToolWorkflowV1 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t};\n\t}\n\n\tasync supplyData(this: ISupplyDataFunctions, itemIndex: number): Promise<SupplyData> {\n\t\tconst workflowProxy = this.getWorkflowDataProxy(0);\n\n\t\tconst name = this.getNodeParameter('name', itemIndex) as string;\n\t\tconst description = this.getNodeParameter('description', itemIndex) as string;\n\n\t\tlet subExecutionId: string | undefined;\n\t\tlet subWorkflowId: string | undefined;\n\n\t\tconst useSchema = this.getNodeParameter('specifyInputSchema', itemIndex) as boolean;\n\t\tlet tool: DynamicTool | DynamicStructuredTool | undefined = undefined;\n\n\t\tconst runFunction = async (\n\t\t\tquery: string | IDataObject,\n\t\t\trunManager?: CallbackManagerForToolRun,\n\t\t): Promise<string> => {\n\t\t\tconst source = this.getNodeParameter('source', itemIndex) as string;\n\t\t\tconst workflowInfo: IExecuteWorkflowInfo = {};\n\t\t\tif (source === 'database') {\n\t\t\t\t// Read workflow from database\n\t\t\t\tconst nodeVersion = this.getNode().typeVersion;\n\t\t\t\tif (nodeVersion <= 1.1) {\n\t\t\t\t\tworkflowInfo.id = this.getNodeParameter('workflowId', itemIndex) as string;\n\t\t\t\t} else {\n\t\t\t\t\tconst { value } = this.getNodeParameter(\n\t\t\t\t\t\t'workflowId',\n\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\t{},\n\t\t\t\t\t) as INodeParameterResourceLocator;\n\t\t\t\t\tworkflowInfo.id = value as string;\n\t\t\t\t}\n\n\t\t\t\tsubWorkflowId = workflowInfo.id;\n\t\t\t} else if (source === 'parameter') {\n\t\t\t\t// Read workflow from parameter\n\t\t\t\tconst workflowJson = this.getNodeParameter('workflowJson', itemIndex) as string;\n\t\t\t\ttry {\n\t\t\t\t\tworkflowInfo.code = JSON.parse(workflowJson) as IWorkflowBase;\n\n\t\t\t\t\t// subworkflow is same as parent workflow\n\t\t\t\t\tsubWorkflowId = workflowProxy.$workflow.id;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t\t`The provided workflow is not valid JSON: \"${(error as Error).message}\"`,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst rawData: IDataObject = { query };\n\n\t\t\tconst workflowFieldsJson = this.getNodeParameter('fields.values', itemIndex, [], {\n\t\t\t\trawExpressions: true,\n\t\t\t}) as SetField[];\n\n\t\t\t// Copied from Set Node v2\n\t\t\tfor (const entry of workflowFieldsJson) {\n\t\t\t\tif (entry.type === 'objectValue' && (entry.objectValue as string).startsWith('=')) {\n\t\t\t\t\trawData[entry.name] = (entry.objectValue as string).replace(/^=+/, '');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst options: SetNodeOptions = {\n\t\t\t\tinclude: 'all',\n\t\t\t};\n\n\t\t\tconst newItem = await manual.execute.call(\n\t\t\t\tthis,\n\t\t\t\t{ json: { query } },\n\t\t\t\titemIndex,\n\t\t\t\toptions,\n\t\t\t\trawData,\n\t\t\t\tthis.getNode(),\n\t\t\t);\n\n\t\t\tconst items = [newItem] as INodeExecutionData[];\n\n\t\t\tlet receivedData: ExecuteWorkflowData;\n\t\t\ttry {\n\t\t\t\treceivedData = await this.executeWorkflow(workflowInfo, items, runManager?.getChild(), {\n\t\t\t\t\tparentExecution: {\n\t\t\t\t\t\texecutionId: workflowProxy.$execution.id,\n\t\t\t\t\t\tworkflowId: workflowProxy.$workflow.id,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\tsubExecutionId = receivedData.executionId;\n\t\t\t} catch (error) {\n\t\t\t\t// Make sure a valid error gets returned that can by json-serialized else it will\n\t\t\t\t// not show up in the frontend\n\t\t\t\tthrow new NodeOperationError(this.getNode(), error as Error);\n\t\t\t}\n\n\t\t\tconst response: string | undefined = get(receivedData, 'data[0][0].json') as\n\t\t\t\t| string\n\t\t\t\t| undefined;\n\t\t\tif (response === undefined) {\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t'There was an error: \"The workflow did not return a response\"',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn response;\n\t\t};\n\n\t\tconst toolHandler = async (\n\t\t\tquery: string | IDataObject,\n\t\t\trunManager?: CallbackManagerForToolRun,\n\t\t): Promise<string> => {\n\t\t\tconst { index } = this.addInputData(NodeConnectionTypes.AiTool, [[{ json: { query } }]]);\n\n\t\t\tlet response: string = '';\n\t\t\tlet executionError: ExecutionError | undefined;\n\t\t\ttry {\n\t\t\t\tresponse = await runFunction(query, runManager);\n\t\t\t} catch (error) {\n\t\t\t\t// TODO: Do some more testing. Issues here should actually fail the workflow\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\t\t\t\texecutionError = error;\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\t\t\tresponse = `There was an error: \"${error.message}\"`;\n\t\t\t}\n\n\t\t\tif (typeof response === 'number') {\n\t\t\t\tresponse = (response as number).toString();\n\t\t\t}\n\n\t\t\tif (isObject(response)) {\n\t\t\t\tresponse = JSON.stringify(response, null, 2);\n\t\t\t}\n\n\t\t\tif (typeof response !== 'string') {\n\t\t\t\t// TODO: Do some more testing. Issues here should actually fail the workflow\n\t\t\t\texecutionError = new NodeOperationError(this.getNode(), 'Wrong output type returned', {\n\t\t\t\t\tdescription: `The response property should be a string, but it is an ${typeof response}`,\n\t\t\t\t});\n\t\t\t\tresponse = `There was an error: \"${executionError.message}\"`;\n\t\t\t}\n\n\t\t\tlet metadata: ITaskMetadata | undefined;\n\t\t\tif (subExecutionId && subWorkflowId) {\n\t\t\t\tmetadata = {\n\t\t\t\t\tsubExecution: {\n\t\t\t\t\t\texecutionId: subExecutionId,\n\t\t\t\t\t\tworkflowId: subWorkflowId,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (executionError) {\n\t\t\t\tvoid this.addOutputData(NodeConnectionTypes.AiTool, index, executionError, metadata);\n\t\t\t} else {\n\t\t\t\t// Output always needs to be an object\n\t\t\t\t// so we try to parse the response as JSON and if it fails we just return the string wrapped in an object\n\t\t\t\tconst json = jsonParse<IDataObject>(response, { fallbackValue: { response } });\n\t\t\t\tvoid this.addOutputData(NodeConnectionTypes.AiTool, index, [[{ json }]], metadata);\n\t\t\t}\n\t\t\treturn response;\n\t\t};\n\n\t\tconst functionBase = {\n\t\t\tname,\n\t\t\tdescription,\n\t\t\tfunc: toolHandler,\n\t\t};\n\n\t\tif (useSchema) {\n\t\t\ttry {\n\t\t\t\t// We initialize these even though one of them will always be empty\n\t\t\t\t// it makes it easier to navigate the ternary operator\n\t\t\t\tconst jsonExample = this.getNodeParameter('jsonSchemaExample', itemIndex, '') as string;\n\t\t\t\tconst inputSchema = this.getNodeParameter('inputSchema', itemIndex, '') as string;\n\n\t\t\t\tconst schemaType = this.getNodeParameter('schemaType', itemIndex) as 'fromJson' | 'manual';\n\t\t\t\tconst jsonSchema =\n\t\t\t\t\tschemaType === 'fromJson'\n\t\t\t\t\t\t? generateSchemaFromExample(jsonExample)\n\t\t\t\t\t\t: jsonParse<JSONSchema7>(inputSchema);\n\n\t\t\t\tconst zodSchema = convertJsonSchemaToZod<DynamicZodObject>(jsonSchema);\n\n\t\t\t\ttool = new DynamicStructuredTool({\n\t\t\t\t\tschema: zodSchema,\n\t\t\t\t\t...functionBase,\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t'Error during parsing of JSON Schema. \\n ' + error,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\ttool = new DynamicTool(functionBase);\n\t\t}\n\n\t\treturn {\n\t\t\tresponse: tool,\n\t\t};\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,mBAAmD;AAEnD,iBAAgB;AAChB,sBAAqB;AAErB,aAAwB;AAgBxB,0BAAmE;AAEnE,gCAAmC;AAEnC,2BAAkE;AAE3D,MAAM,eAAoC;AAAA,EAGhD,YAAY,iBAA2C;AACtD,SAAK,cAAc;AAAA,MAClB,GAAG;AAAA,MACH,GAAG;AAAA,IACJ;AAAA,EACD;AAAA,EAEA,MAAM,WAAuC,WAAwC;AACpF,UAAM,gBAAgB,KAAK,qBAAqB,CAAC;AAEjD,UAAM,OAAO,KAAK,iBAAiB,QAAQ,SAAS;AACpD,UAAM,cAAc,KAAK,iBAAiB,eAAe,SAAS;AAElE,QAAI;AACJ,QAAI;AAEJ,UAAM,YAAY,KAAK,iBAAiB,sBAAsB,SAAS;AACvE,QAAI,OAAwD;AAE5D,UAAM,cAAc,OACnB,OACA,eACqB;AACrB,YAAM,SAAS,KAAK,iBAAiB,UAAU,SAAS;AACxD,YAAM,eAAqC,CAAC;AAC5C,UAAI,WAAW,YAAY;AAE1B,cAAM,cAAc,KAAK,QAAQ,EAAE;AACnC,YAAI,eAAe,KAAK;AACvB,uBAAa,KAAK,KAAK,iBAAiB,cAAc,SAAS;AAAA,QAChE,OAAO;AACN,gBAAM,EAAE,MAAM,IAAI,KAAK;AAAA,YACtB;AAAA,YACA;AAAA,YACA,CAAC;AAAA,UACF;AACA,uBAAa,KAAK;AAAA,QACnB;AAEA,wBAAgB,aAAa;AAAA,MAC9B,WAAW,WAAW,aAAa;AAElC,cAAM,eAAe,KAAK,iBAAiB,gBAAgB,SAAS;AACpE,YAAI;AACH,uBAAa,OAAO,KAAK,MAAM,YAAY;AAG3C,0BAAgB,cAAc,UAAU;AAAA,QACzC,SAAS,OAAO;AACf,gBAAM,IAAI;AAAA,YACT,KAAK,QAAQ;AAAA,YACb,6CAA8C,MAAgB,OAAO;AAAA,YACrE;AAAA,cACC;AAAA,YACD;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAEA,YAAM,UAAuB,EAAE,MAAM;AAErC,YAAM,qBAAqB,KAAK,iBAAiB,iBAAiB,WAAW,CAAC,GAAG;AAAA,QAChF,gBAAgB;AAAA,MACjB,CAAC;AAGD,iBAAW,SAAS,oBAAoB;AACvC,YAAI,MAAM,SAAS,iBAAkB,MAAM,YAAuB,WAAW,GAAG,GAAG;AAClF,kBAAQ,MAAM,IAAI,IAAK,MAAM,YAAuB,QAAQ,OAAO,EAAE;AAAA,QACtE;AAAA,MACD;AAEA,YAAM,UAA0B;AAAA,QAC/B,SAAS;AAAA,MACV;AAEA,YAAM,UAAU,MAAM,OAAO,QAAQ;AAAA,QACpC;AAAA,QACA,EAAE,MAAM,EAAE,MAAM,EAAE;AAAA,QAClB;AAAA,QACA;AAAA,QACA;AAAA,QACA,KAAK,QAAQ;AAAA,MACd;AAEA,YAAM,QAAQ,CAAC,OAAO;AAEtB,UAAI;AACJ,UAAI;AACH,uBAAe,MAAM,KAAK,gBAAgB,cAAc,OAAO,YAAY,SAAS,GAAG;AAAA,UACtF,iBAAiB;AAAA,YAChB,aAAa,cAAc,WAAW;AAAA,YACtC,YAAY,cAAc,UAAU;AAAA,UACrC;AAAA,QACD,CAAC;AACD,yBAAiB,aAAa;AAAA,MAC/B,SAAS,OAAO;AAGf,cAAM,IAAI,uCAAmB,KAAK,QAAQ,GAAG,KAAc;AAAA,MAC5D;AAEA,YAAM,eAA+B,WAAAA,SAAI,cAAc,iBAAiB;AAGxE,UAAI,aAAa,QAAW;AAC3B,cAAM,IAAI;AAAA,UACT,KAAK,QAAQ;AAAA,UACb;AAAA,QACD;AAAA,MACD;AAEA,aAAO;AAAA,IACR;AAEA,UAAM,cAAc,OACnB,OACA,eACqB;AACrB,YAAM,EAAE,MAAM,IAAI,KAAK,aAAa,wCAAoB,QAAQ,CAAC,CAAC,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC;AAEvF,UAAI,WAAmB;AACvB,UAAI;AACJ,UAAI;AACH,mBAAW,MAAM,YAAY,OAAO,UAAU;AAAA,MAC/C,SAAS,OAAO;AAGf,yBAAiB;AAEjB,mBAAW,wBAAwB,MAAM,OAAO;AAAA,MACjD;AAEA,UAAI,OAAO,aAAa,UAAU;AACjC,mBAAY,SAAoB,SAAS;AAAA,MAC1C;AAEA,cAAI,gBAAAC,SAAS,QAAQ,GAAG;AACvB,mBAAW,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,MAC5C;AAEA,UAAI,OAAO,aAAa,UAAU;AAEjC,yBAAiB,IAAI,uCAAmB,KAAK,QAAQ,GAAG,8BAA8B;AAAA,UACrF,aAAa,0DAA0D,OAAO,QAAQ;AAAA,QACvF,CAAC;AACD,mBAAW,wBAAwB,eAAe,OAAO;AAAA,MAC1D;AAEA,UAAI;AACJ,UAAI,kBAAkB,eAAe;AACpC,mBAAW;AAAA,UACV,cAAc;AAAA,YACb,aAAa;AAAA,YACb,YAAY;AAAA,UACb;AAAA,QACD;AAAA,MACD;AAEA,UAAI,gBAAgB;AACnB,aAAK,KAAK,cAAc,wCAAoB,QAAQ,OAAO,gBAAgB,QAAQ;AAAA,MACpF,OAAO;AAGN,cAAM,WAAO,+BAAuB,UAAU,EAAE,eAAe,EAAE,SAAS,EAAE,CAAC;AAC7E,aAAK,KAAK,cAAc,wCAAoB,QAAQ,OAAO,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,QAAQ;AAAA,MAClF;AACA,aAAO;AAAA,IACR;AAEA,UAAM,eAAe;AAAA,MACpB;AAAA,MACA;AAAA,MACA,MAAM;AAAA,IACP;AAEA,QAAI,WAAW;AACd,UAAI;AAGH,cAAM,cAAc,KAAK,iBAAiB,qBAAqB,WAAW,EAAE;AAC5E,cAAM,cAAc,KAAK,iBAAiB,eAAe,WAAW,EAAE;AAEtE,cAAM,aAAa,KAAK,iBAAiB,cAAc,SAAS;AAChE,cAAM,aACL,eAAe,iBACZ,gDAA0B,WAAW,QACrC,+BAAuB,WAAW;AAEtC,cAAM,gBAAY,6CAAyC,UAAU;AAErE,eAAO,IAAI,mCAAsB;AAAA,UAChC,QAAQ;AAAA,UACR,GAAG;AAAA,QACJ,CAAC;AAAA,MACF,SAAS,OAAO;AACf,cAAM,IAAI;AAAA,UACT,KAAK,QAAQ;AAAA,UACb,6CAA6C;AAAA,QAC9C;AAAA,MACD;AAAA,IACD,OAAO;AACN,aAAO,IAAI,yBAAY,YAAY;AAAA,IACpC;AAEA,WAAO;AAAA,MACN,UAAU;AAAA,IACX;AAAA,EACD;AACD;","names":["get","isObject"]}