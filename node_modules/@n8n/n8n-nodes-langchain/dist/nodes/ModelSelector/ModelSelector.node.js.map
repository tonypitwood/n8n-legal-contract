{"version":3,"sources":["../../../nodes/ModelSelector/ModelSelector.node.ts"],"sourcesContent":["/* eslint-disable n8n-nodes-base/node-param-description-wrong-for-dynamic-options */\n/* eslint-disable n8n-nodes-base/node-param-display-name-wrong-for-dynamic-options */\nimport type { BaseCallbackHandler, CallbackHandlerMethods } from '@langchain/core/callbacks/base';\nimport type { Callbacks } from '@langchain/core/callbacks/manager';\nimport type { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport {\n\tNodeConnectionTypes,\n\ttype INodeType,\n\ttype INodeTypeDescription,\n\ttype ISupplyDataFunctions,\n\ttype SupplyData,\n\ttype ILoadOptionsFunctions,\n\tNodeOperationError,\n} from 'n8n-workflow';\n\nimport { numberInputsProperty, configuredInputs } from './helpers';\nimport { N8nLlmTracing } from '../llms/N8nLlmTracing';\nimport { N8nNonEstimatingTracing } from '../llms/N8nNonEstimatingTracing';\n\ninterface ModeleSelectionRule {\n\tmodelIndex: number;\n\tconditions: {\n\t\toptions: {\n\t\t\tcaseSensitive: boolean;\n\t\t\ttypeValidation: 'strict' | 'loose';\n\t\t\tleftValue: string;\n\t\t\tversion: 1 | 2;\n\t\t};\n\t\tconditions: Array<{\n\t\t\tid: string;\n\t\t\tleftValue: string;\n\t\t\trightValue: string;\n\t\t\toperator: {\n\t\t\t\ttype: string;\n\t\t\t\toperation: string;\n\t\t\t\tname: string;\n\t\t\t};\n\t\t}>;\n\t\tcombinator: 'and' | 'or';\n\t};\n}\n\nfunction getCallbacksArray(\n\tcallbacks: Callbacks | undefined,\n): Array<BaseCallbackHandler | CallbackHandlerMethods> {\n\tif (!callbacks) return [];\n\n\tif (Array.isArray(callbacks)) {\n\t\treturn callbacks;\n\t}\n\n\t// If it's a CallbackManager, extract its handlers\n\treturn callbacks.handlers || [];\n}\n\nexport class ModelSelector implements INodeType {\n\tdescription: INodeTypeDescription = {\n\t\tdisplayName: 'Model Selector',\n\t\tname: 'modelSelector',\n\t\ticon: 'fa:map-signs',\n\t\ticonColor: 'green',\n\t\tdefaults: {\n\t\t\tname: 'Model Selector',\n\t\t},\n\t\tversion: 1,\n\t\tgroup: ['transform'],\n\t\tdescription:\n\t\t\t'Use this node to select one of the connected models to this node based on workflow data',\n\t\tinputs: `={{\n\t\t\t\t((parameters) => {\n\t\t\t\t\t${configuredInputs.toString()};\n\t\t\t\t\treturn configuredInputs(parameters)\n\t\t\t\t})($parameter)\n\t\t\t}}`,\n\t\tcodex: {\n\t\t\tcategories: ['AI'],\n\t\t\tsubcategories: {\n\t\t\t\tAI: ['Language Models'],\n\t\t\t},\n\t\t\tresources: {\n\t\t\t\tprimaryDocumentation: [\n\t\t\t\t\t{\n\t\t\t\t\t\turl: 'https://docs.n8n.io/integrations/builtin/cluster-nodes/sub-nodes/n8n-nodes-langchain.modelselector/',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t},\n\t\toutputs: [NodeConnectionTypes.AiLanguageModel],\n\t\trequiredInputs: 1,\n\t\tproperties: [\n\t\t\tnumberInputsProperty,\n\t\t\t{\n\t\t\t\tdisplayName: 'Rules',\n\t\t\t\tname: 'rules',\n\t\t\t\tplaceholder: 'Add Rule',\n\t\t\t\ttype: 'fixedCollection',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tmultipleValues: true,\n\t\t\t\t\tsortable: true,\n\t\t\t\t},\n\t\t\t\tdescription: 'Rules to map workflow data to specific models',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Rule',\n\t\t\t\t\t\tname: 'rule',\n\t\t\t\t\t\tvalues: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdisplayName: 'Model',\n\t\t\t\t\t\t\t\tname: 'modelIndex',\n\t\t\t\t\t\t\t\ttype: 'options',\n\t\t\t\t\t\t\t\tdescription: 'Choose model input from the list',\n\t\t\t\t\t\t\t\tdefault: 1,\n\t\t\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\t\t\tplaceholder: 'Choose model input from the list',\n\t\t\t\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\t\t\t\tloadOptionsMethod: 'getModels',\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdisplayName: 'Conditions',\n\t\t\t\t\t\t\t\tname: 'conditions',\n\t\t\t\t\t\t\t\tplaceholder: 'Add Condition',\n\t\t\t\t\t\t\t\ttype: 'filter',\n\t\t\t\t\t\t\t\tdefault: {},\n\t\t\t\t\t\t\t\ttypeOptions: {\n\t\t\t\t\t\t\t\t\tfilter: {\n\t\t\t\t\t\t\t\t\t\tcaseSensitive: true,\n\t\t\t\t\t\t\t\t\t\ttypeValidation: 'strict',\n\t\t\t\t\t\t\t\t\t\tversion: 2,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tdescription: 'Conditions that must be met to select this model',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t};\n\n\tmethods = {\n\t\tloadOptions: {\n\t\t\tasync getModels(this: ILoadOptionsFunctions) {\n\t\t\t\tconst numberInputs = this.getCurrentNodeParameter('numberInputs') as number;\n\n\t\t\t\treturn Array.from({ length: numberInputs ?? 2 }, (_, i) => ({\n\t\t\t\t\tvalue: i + 1,\n\t\t\t\t\tname: `Model ${(i + 1).toString()}`,\n\t\t\t\t}));\n\t\t\t},\n\t\t},\n\t};\n\n\tasync supplyData(this: ISupplyDataFunctions, itemIndex: number): Promise<SupplyData> {\n\t\tconst models = (await this.getInputConnectionData(\n\t\t\tNodeConnectionTypes.AiLanguageModel,\n\t\t\titemIndex,\n\t\t)) as unknown[];\n\n\t\tif (!models || models.length === 0) {\n\t\t\tthrow new NodeOperationError(this.getNode(), 'No models connected', {\n\t\t\t\titemIndex,\n\t\t\t\tdescription: 'No models found in input connections',\n\t\t\t});\n\t\t}\n\t\tmodels.reverse();\n\n\t\tconst rules = this.getNodeParameter('rules.rule', itemIndex, []) as ModeleSelectionRule[];\n\n\t\tif (!rules || rules.length === 0) {\n\t\t\tthrow new NodeOperationError(this.getNode(), 'No rules defined', {\n\t\t\t\titemIndex,\n\t\t\t\tdescription: 'At least one rule must be defined to select a model',\n\t\t\t});\n\t\t}\n\n\t\tfor (let i = 0; i < rules.length; i++) {\n\t\t\tconst rule = rules[i];\n\t\t\tconst modelIndex = rule.modelIndex;\n\n\t\t\tif (modelIndex <= 0 || modelIndex > models.length) {\n\t\t\t\tthrow new NodeOperationError(this.getNode(), `Invalid model index ${modelIndex}`, {\n\t\t\t\t\titemIndex,\n\t\t\t\t\tdescription: `Model index must be between 1 and ${models.length}`,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst conditionsMet = this.getNodeParameter(`rules.rule[${i}].conditions`, itemIndex, false, {\n\t\t\t\textractValue: true,\n\t\t\t}) as boolean;\n\n\t\t\tif (conditionsMet) {\n\t\t\t\tconst selectedModel = models[modelIndex - 1] as BaseChatModel;\n\n\t\t\t\tconst originalCallbacks = getCallbacksArray(selectedModel.callbacks);\n\n\t\t\t\tfor (const currentCallback of originalCallbacks) {\n\t\t\t\t\tif (currentCallback instanceof N8nLlmTracing) {\n\t\t\t\t\t\tcurrentCallback.setParentRunIndex(this.getNextRunIndex());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst modelSelectorTracing = new N8nNonEstimatingTracing(this);\n\t\t\t\tselectedModel.callbacks = [...originalCallbacks, modelSelectorTracing];\n\n\t\t\t\treturn {\n\t\t\t\t\tresponse: selectedModel,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tthrow new NodeOperationError(this.getNode(), 'No matching rule found', {\n\t\t\titemIndex,\n\t\t\tdescription: 'None of the defined rules matched the workflow data',\n\t\t});\n\t}\n}\n"],"mappings":"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","names":[]}