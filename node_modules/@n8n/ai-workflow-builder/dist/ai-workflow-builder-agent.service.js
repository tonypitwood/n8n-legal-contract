"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var AiWorkflowBuilderService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AiWorkflowBuilderService = void 0;
const tracer_langchain_1 = require("@langchain/core/tracers/tracer_langchain");
const backend_common_1 = require("@n8n/backend-common");
const di_1 = require("@n8n/di");
const ai_assistant_sdk_1 = require("@n8n_io/ai-assistant-sdk");
const assert_1 = __importDefault(require("assert"));
const langsmith_1 = require("langsmith");
const errors_1 = require("./errors");
const llm_config_1 = require("./llm-config");
const session_manager_service_1 = require("./session-manager.service");
const workflow_builder_agent_1 = require("./workflow-builder-agent");
let AiWorkflowBuilderService = AiWorkflowBuilderService_1 = class AiWorkflowBuilderService {
    nodeTypes;
    client;
    logger;
    instanceUrl;
    onCreditsUpdated;
    parsedNodeTypes = [];
    sessionManager;
    constructor(nodeTypes, client, logger, instanceUrl, onCreditsUpdated) {
        this.nodeTypes = nodeTypes;
        this.client = client;
        this.logger = logger;
        this.instanceUrl = instanceUrl;
        this.onCreditsUpdated = onCreditsUpdated;
        this.parsedNodeTypes = this.getNodeTypes();
        this.sessionManager = new session_manager_service_1.SessionManagerService(this.parsedNodeTypes, logger);
    }
    static async getAnthropicClaudeModel({ baseUrl, authHeaders = {}, apiKey = '-', } = {}) {
        return await (0, llm_config_1.anthropicClaudeSonnet4)({
            baseUrl,
            apiKey,
            headers: {
                ...authHeaders,
                'anthropic-beta': 'prompt-caching-2024-07-31',
            },
        });
    }
    async getApiProxyAuthHeaders(user, useDeprecatedCredentials = false) {
        (0, assert_1.default)(this.client);
        let authHeaders;
        if (useDeprecatedCredentials) {
            const authResponse = await this.client.generateApiProxyCredentials(user);
            authHeaders = { Authorization: authResponse.apiKey };
        }
        else {
            const authResponse = await this.client.getBuilderApiProxyToken(user);
            authHeaders = {
                Authorization: `${authResponse.tokenType} ${authResponse.accessToken}`,
            };
        }
        return authHeaders;
    }
    async setupModels(user, useDeprecatedCredentials = false) {
        try {
            if (this.client) {
                const authHeaders = await this.getApiProxyAuthHeaders(user, useDeprecatedCredentials);
                const baseUrl = this.client.getApiProxyBaseUrl();
                const anthropicClaude = await AiWorkflowBuilderService_1.getAnthropicClaudeModel({
                    baseUrl: baseUrl + '/anthropic',
                    authHeaders,
                });
                const tracingClient = new langsmith_1.Client({
                    apiKey: '-',
                    apiUrl: baseUrl + '/langsmith',
                    autoBatchTracing: false,
                    traceBatchConcurrency: 1,
                    fetchOptions: {
                        headers: {
                            ...authHeaders,
                        },
                    },
                });
                return { tracingClient, anthropicClaude, authHeaders };
            }
            const anthropicClaude = await AiWorkflowBuilderService_1.getAnthropicClaudeModel({
                apiKey: process.env.N8N_AI_ANTHROPIC_KEY ?? '',
            });
            return { anthropicClaude };
        }
        catch (error) {
            const errorMessage = error instanceof Error ? `: ${error.message}` : '';
            const llmError = new errors_1.LLMServiceError(`Failed to connect to LLM Provider${errorMessage}`, {
                cause: error,
                tags: {
                    hasClient: !!this.client,
                    hasUser: !!user,
                },
            });
            throw llmError;
        }
    }
    getNodeTypes() {
        const ignoredTypes = [
            '@n8n/n8n-nodes-langchain.toolVectorStore',
            '@n8n/n8n-nodes-langchain.documentGithubLoader',
            '@n8n/n8n-nodes-langchain.code',
        ];
        const nodeTypesKeys = Object.keys(this.nodeTypes.getKnownTypes());
        const nodeTypes = nodeTypesKeys
            .filter((nodeType) => !ignoredTypes.includes(nodeType))
            .map((nodeName) => {
            try {
                return { ...this.nodeTypes.getByNameAndVersion(nodeName).description, name: nodeName };
            }
            catch (error) {
                this.logger?.error('Error getting node type', {
                    nodeName,
                    error: error instanceof Error ? error.message : 'Unknown error',
                });
                return undefined;
            }
        })
            .filter((nodeType) => nodeType !== undefined && nodeType.hidden !== true)
            .map((nodeType, _index, nodeTypes) => {
            const isTool = nodeType.name.endsWith('Tool');
            if (!isTool)
                return nodeType;
            const nonToolNode = nodeTypes.find((nt) => nt.name === nodeType.name.replace('Tool', ''));
            if (!nonToolNode)
                return nodeType;
            return {
                ...nonToolNode,
                ...nodeType,
            };
        });
        return nodeTypes;
    }
    async getAgent(user, useDeprecatedCredentials = false) {
        const { anthropicClaude, tracingClient, authHeaders } = await this.setupModels(user, useDeprecatedCredentials);
        const agent = new workflow_builder_agent_1.WorkflowBuilderAgent({
            parsedNodeTypes: this.parsedNodeTypes,
            llmSimpleTask: anthropicClaude,
            llmComplexTask: anthropicClaude,
            logger: this.logger,
            checkpointer: this.sessionManager.getCheckpointer(),
            tracer: tracingClient
                ? new tracer_langchain_1.LangChainTracer({ client: tracingClient, projectName: 'n8n-workflow-builder' })
                : undefined,
            instanceUrl: this.instanceUrl,
            onGenerationSuccess: async () => {
                if (!useDeprecatedCredentials) {
                    await this.onGenerationSuccess(user, authHeaders);
                }
            },
        });
        return agent;
    }
    async onGenerationSuccess(user, authHeaders) {
        try {
            if (this.client) {
                (0, assert_1.default)(authHeaders, 'Auth headers must be set when AI Assistant Service client is used');
                (0, assert_1.default)(user);
                const creditsInfo = await this.client.markBuilderSuccess(user, authHeaders);
                if (this.onCreditsUpdated && user.id && creditsInfo) {
                    this.onCreditsUpdated(user.id, creditsInfo.creditsQuota, creditsInfo.creditsClaimed);
                }
            }
        }
        catch (error) {
            if (error instanceof Error) {
                this.logger?.error(`Unable to mark generation success ${error.message}`, { error });
            }
        }
    }
    async *chat(payload, user, abortSignal) {
        const agent = await this.getAgent(user, payload.useDeprecatedCredentials);
        for await (const output of agent.chat(payload, user?.id?.toString(), abortSignal)) {
            yield output;
        }
    }
    async getSessions(workflowId, user) {
        const userId = user?.id?.toString();
        return await this.sessionManager.getSessions(workflowId, userId);
    }
    async getBuilderInstanceCredits(user) {
        if (this.client) {
            return await this.client.getBuilderInstanceCredits(user);
        }
        return {
            creditsQuota: -1,
            creditsClaimed: 0,
        };
    }
};
exports.AiWorkflowBuilderService = AiWorkflowBuilderService;
exports.AiWorkflowBuilderService = AiWorkflowBuilderService = AiWorkflowBuilderService_1 = __decorate([
    (0, di_1.Service)(),
    __metadata("design:paramtypes", [Object, ai_assistant_sdk_1.AiAssistantClient,
        backend_common_1.Logger, String, Function])
], AiWorkflowBuilderService);
//# sourceMappingURL=ai-workflow-builder-agent.service.js.map