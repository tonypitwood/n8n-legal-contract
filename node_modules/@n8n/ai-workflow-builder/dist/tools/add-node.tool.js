"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeCreationSchema = void 0;
exports.getAddNodeToolBase = getAddNodeToolBase;
exports.createAddNodeTool = createAddNodeTool;
const tools_1 = require("@langchain/core/tools");
const zod_1 = require("zod");
const errors_1 = require("../errors");
const node_creation_utils_1 = require("./utils/node-creation.utils");
const node_positioning_utils_1 = require("./utils/node-positioning.utils");
const node_helpers_1 = require("../utils/node-helpers");
const progress_1 = require("./helpers/progress");
const response_1 = require("./helpers/response");
const state_1 = require("./helpers/state");
const validation_1 = require("./helpers/validation");
exports.nodeCreationSchema = zod_1.z.object({
    nodeType: zod_1.z.string().describe('The type of node to add (e.g., n8n-nodes-base.httpRequest)'),
    name: zod_1.z
        .string()
        .describe('A descriptive name for the node that clearly indicates its purpose in the workflow'),
    connectionParametersReasoning: zod_1.z
        .string()
        .describe('REQUIRED: Explain your reasoning about connection parameters. Consider: Does this node have dynamic inputs/outputs? Does it need mode/operation parameters? For example: "Vector Store has dynamic inputs based on mode, so I need to set mode:insert for document input" or "HTTP Request has static inputs, so no special parameters needed"'),
    connectionParameters: zod_1.z
        .object({})
        .passthrough()
        .describe('Parameters that affect node connections (e.g., mode: "insert" for Vector Store). Pass an empty object {} if no connection parameters are needed. Only connection-affecting parameters like mode, operation, resource, action, etc. are allowed.'),
});
function createNode(nodeType, customName, existingNodes, nodeTypes, connectionParameters) {
    const baseName = customName ?? nodeType.defaults?.name ?? nodeType.displayName;
    const uniqueName = (0, node_creation_utils_1.generateUniqueName)(baseName, existingNodes);
    const position = (0, node_positioning_utils_1.calculateNodePosition)(existingNodes, (0, node_helpers_1.isSubNode)(nodeType), nodeTypes);
    return (0, node_creation_utils_1.createNodeInstance)(nodeType, uniqueName, position, connectionParameters);
}
function buildResponseMessage(addedNode, nodeTypes) {
    const nodeType = nodeTypes.find((nt) => nt.name === addedNode.type);
    const nodeTypeInfo = nodeType && (0, node_helpers_1.isSubNode)(nodeType) ? ' (sub-node)' : '';
    return `Successfully added "${addedNode.name}" (${addedNode.displayName ?? addedNode.type})${nodeTypeInfo} with ID ${addedNode.id}`;
}
function getCustomNodeTitle(input, nodeTypes) {
    if ('nodeType' in input && typeof input['nodeType'] === 'string') {
        const nodeType = nodeTypes.find((type) => type.name === input.nodeType);
        if (nodeType) {
            return `Adding ${nodeType.displayName} node`;
        }
    }
    return 'Adding node';
}
function getAddNodeToolBase(nodeTypes) {
    return {
        toolName: 'add_nodes',
        displayTitle: 'Adding nodes',
        getCustomDisplayTitle: (input) => getCustomNodeTitle(input, nodeTypes),
    };
}
function createAddNodeTool(nodeTypes) {
    const builderToolBase = getAddNodeToolBase(nodeTypes);
    const dynamicTool = (0, tools_1.tool)(async (input, config) => {
        const reporter = (0, progress_1.createProgressReporter)(config, builderToolBase.toolName, builderToolBase.displayTitle, getCustomNodeTitle(input, nodeTypes));
        try {
            const validatedInput = exports.nodeCreationSchema.parse(input);
            const { nodeType, name, connectionParametersReasoning, connectionParameters } = validatedInput;
            reporter.start(validatedInput);
            const state = (0, state_1.getWorkflowState)();
            const workflow = (0, state_1.getCurrentWorkflow)(state);
            reporter.progress(`Adding ${name} (${connectionParametersReasoning})`);
            const nodeTypeDesc = (0, validation_1.findNodeType)(nodeType, nodeTypes);
            if (!nodeTypeDesc) {
                const nodeError = new errors_1.NodeTypeNotFoundError(nodeType);
                const error = {
                    message: nodeError.message,
                    code: 'NODE_TYPE_NOT_FOUND',
                    details: { nodeType },
                };
                reporter.error(error);
                return (0, response_1.createErrorResponse)(config, error);
            }
            const newNode = createNode(nodeTypeDesc, name, workflow.nodes, nodeTypes, connectionParameters);
            const addedNodeInfo = {
                id: newNode.id,
                name: newNode.name,
                type: newNode.type,
                displayName: nodeTypeDesc.displayName,
                position: newNode.position,
                parameters: newNode.parameters,
            };
            const message = buildResponseMessage(addedNodeInfo, nodeTypes);
            const output = {
                addedNode: addedNodeInfo,
                message,
            };
            reporter.complete(output);
            const stateUpdates = (0, state_1.addNodeToWorkflow)(newNode);
            return (0, response_1.createSuccessResponse)(config, message, stateUpdates);
        }
        catch (error) {
            let toolError;
            if (error instanceof zod_1.z.ZodError) {
                const validationError = new errors_1.ValidationError('Invalid input parameters', {
                    field: error.errors[0]?.path.join('.'),
                    value: error.errors[0]?.message,
                });
                toolError = {
                    message: validationError.message,
                    code: 'VALIDATION_ERROR',
                    details: error.errors,
                };
            }
            else {
                toolError = {
                    message: error instanceof Error ? error.message : 'Unknown error occurred',
                    code: 'EXECUTION_ERROR',
                };
            }
            reporter.error(toolError);
            return (0, response_1.createErrorResponse)(config, toolError);
        }
    }, {
        name: builderToolBase.toolName,
        description: `Add a node to the workflow canvas. Each node represents a specific action or operation (e.g., HTTP request, data transformation, database query). Always provide descriptive names that explain what the node does (e.g., "Get Customer Data", "Filter Active Users", "Send Email Notification"). The tool handles automatic positioning. Use this tool after searching for available node types to ensure they exist.

To add multiple nodes, call this tool multiple times in parallel.

CRITICAL: You MUST provide:
1. connectionParametersReasoning - Explain why you're choosing specific connection parameters or using {}
2. connectionParameters - The actual parameters (use {} for nodes without special needs)

IMPORTANT: DO NOT rely on default values! Always explicitly set connection-affecting parameters when they exist.

REASONING EXAMPLES:
- "Vector Store has dynamic inputs that change based on mode parameter, setting mode:insert to accept document inputs"
- "HTTP Request has static inputs/outputs, no connection parameters needed"
- "Document Loader needs textSplittingMode:custom to accept text splitter connections"
- "AI Agent has dynamic inputs, setting hasOutputParser:true to enable output parser connections"
- "Set node has standard main connections only, using empty parameters"

CONNECTION PARAMETERS (NEVER rely on defaults - always set explicitly):
- AI Agent (@n8n/n8n-nodes-langchain.agent):
  - For output parser support: { hasOutputParser: true }
  - Without output parser: { hasOutputParser: false }
- Vector Store (@n8n/n8n-nodes-langchain.vectorStoreInMemory):
  - For document input: { mode: "insert" }
  - For querying: { mode: "retrieve" }
  - For AI tool use: { mode: "retrieve-as-tool" }
- Document Loader (@n8n/n8n-nodes-langchain.documentDefaultDataLoader):
  - For text splitter input: { textSplittingMode: "custom" }
  - For built-in splitting: { textSplittingMode: "simple" }
- Regular nodes (HTTP Request, Set, Code, etc.): {}

Think through the connectionParametersReasoning FIRST, then set connectionParameters based on your reasoning. If a parameter affects connections, SET IT EXPLICITLY.`,
        schema: exports.nodeCreationSchema,
    });
    return {
        tool: dynamicTool,
        ...builderToolBase,
    };
}
//# sourceMappingURL=add-node.tool.js.map