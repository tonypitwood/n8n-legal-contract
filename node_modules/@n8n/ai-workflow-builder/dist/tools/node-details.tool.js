"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NODE_DETAILS_TOOL = void 0;
exports.createNodeDetailsTool = createNodeDetailsTool;
const tools_1 = require("@langchain/core/tools");
const zod_1 = require("zod");
const errors_1 = require("../errors");
const progress_1 = require("./helpers/progress");
const response_1 = require("./helpers/response");
const validation_1 = require("./helpers/validation");
const nodeDetailsSchema = zod_1.z.object({
    nodeName: zod_1.z.string().describe('The exact node type name (e.g., n8n-nodes-base.httpRequest)'),
    withParameters: zod_1.z
        .boolean()
        .optional()
        .default(false)
        .describe('Whether to include node parameters in the output'),
    withConnections: zod_1.z
        .boolean()
        .optional()
        .default(true)
        .describe('Whether to include node supported connections in the output'),
});
function formatInputs(inputs) {
    if (!inputs || inputs.length === 0) {
        return '<inputs>none</inputs>';
    }
    if (typeof inputs === 'string') {
        return `<input>${inputs}</input>`;
    }
    const formattedInputs = inputs.map((input) => {
        if (typeof input === 'string') {
            return `<input>${input}</input>`;
        }
        return `<input>${JSON.stringify(input)}</input>`;
    });
    return formattedInputs.join('\n');
}
function formatOutputs(outputs) {
    if (!outputs || outputs.length === 0) {
        return '<outputs>none</outputs>';
    }
    if (typeof outputs === 'string') {
        return `<output>${outputs}</output>`;
    }
    const formattedOutputs = outputs.map((output) => {
        if (typeof output === 'string') {
            return `<output>${output}</output>`;
        }
        return `<output>${JSON.stringify(output)}</output>`;
    });
    return formattedOutputs.join('\n');
}
function formatNodeDetails(details, withParameters = false, withConnections = true) {
    const parts = [];
    parts.push('<node_details>');
    parts.push(`<name>${details.name}</name>`);
    parts.push(`<display_name>${details.displayName}</display_name>`);
    parts.push(`<description>${details.description}</description>`);
    if (details.subtitle) {
        parts.push(`<subtitle>${details.subtitle}</subtitle>`);
    }
    if (withParameters && details.properties.length > 0) {
        const stringifiedProperties = JSON.stringify(details.properties, null, 2);
        parts.push(`<properties>
			${stringifiedProperties.length > 1000 ? stringifiedProperties.slice(0, 1000) + '... Rest of properties omitted' : stringifiedProperties}
			</properties>`);
    }
    if (withConnections) {
        parts.push('<connections>');
        parts.push(formatInputs(details.inputs));
        parts.push(formatOutputs(details.outputs));
        parts.push('</connections>');
    }
    parts.push('</node_details>');
    return parts.join('\n');
}
function extractNodeDetails(nodeType) {
    return {
        name: nodeType.name,
        displayName: nodeType.displayName,
        description: nodeType.description,
        properties: nodeType.properties,
        subtitle: nodeType.subtitle,
        inputs: nodeType.inputs,
        outputs: nodeType.outputs,
    };
}
exports.NODE_DETAILS_TOOL = {
    toolName: 'get_node_details',
    displayTitle: 'Getting node details',
};
function createNodeDetailsTool(nodeTypes) {
    const dynamicTool = (0, tools_1.tool)((input, config) => {
        const reporter = (0, progress_1.createProgressReporter)(config, exports.NODE_DETAILS_TOOL.toolName, exports.NODE_DETAILS_TOOL.displayTitle);
        try {
            const validatedInput = nodeDetailsSchema.parse(input);
            const { nodeName, withParameters, withConnections } = validatedInput;
            reporter.start(validatedInput);
            (0, progress_1.reportProgress)(reporter, `Looking up details for ${nodeName}...`);
            const nodeType = (0, validation_1.findNodeType)(nodeName, nodeTypes);
            if (!nodeType) {
                const error = (0, validation_1.createNodeTypeNotFoundError)(nodeName);
                reporter.error(error);
                return (0, response_1.createErrorResponse)(config, error);
            }
            const details = extractNodeDetails(nodeType);
            const message = formatNodeDetails(details, withParameters, withConnections);
            const output = {
                details,
                found: true,
                message,
            };
            reporter.complete(output);
            return (0, response_1.createSuccessResponse)(config, message);
        }
        catch (error) {
            if (error instanceof zod_1.z.ZodError) {
                const validationError = new errors_1.ValidationError('Invalid input parameters', {
                    extra: { errors: error.errors },
                });
                reporter.error(validationError);
                return (0, response_1.createErrorResponse)(config, validationError);
            }
            const toolError = new errors_1.ToolExecutionError(error instanceof Error ? error.message : 'Unknown error occurred', {
                toolName: exports.NODE_DETAILS_TOOL.toolName,
                cause: error instanceof Error ? error : undefined,
            });
            reporter.error(toolError);
            return (0, response_1.createErrorResponse)(config, toolError);
        }
    }, {
        name: exports.NODE_DETAILS_TOOL.toolName,
        description: 'Get detailed information about a specific n8n node type including properties and available connections. Use this before adding nodes to understand their input/output structure.',
        schema: nodeDetailsSchema,
    });
    return {
        tool: dynamicTool,
        ...exports.NODE_DETAILS_TOOL,
    };
}
//# sourceMappingURL=node-details.tool.js.map