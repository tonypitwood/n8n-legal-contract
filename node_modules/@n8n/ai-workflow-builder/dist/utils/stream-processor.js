"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_WORKFLOW_UPDATE_TOOLS = void 0;
exports.processStreamChunk = processStreamChunk;
exports.createStreamProcessor = createStreamProcessor;
exports.formatMessages = formatMessages;
const messages_1 = require("@langchain/core/messages");
exports.DEFAULT_WORKFLOW_UPDATE_TOOLS = [
    'add_nodes',
    'connect_nodes',
    'update_node_parameters',
    'remove_node',
];
function processStreamChunk(streamMode, chunk) {
    if (streamMode === 'updates') {
        const agentChunk = chunk;
        if ((agentChunk?.delete_messages?.messages ?? []).length > 0) {
            const messageChunk = {
                role: 'assistant',
                type: 'message',
                text: 'Deleted, refresh?',
            };
            return { messages: [messageChunk] };
        }
        if ((agentChunk?.compact_messages?.messages ?? []).length > 0) {
            const lastMessage = agentChunk.compact_messages.messages[agentChunk.compact_messages.messages.length - 1];
            const messageChunk = {
                role: 'assistant',
                type: 'message',
                text: lastMessage.content,
            };
            return { messages: [messageChunk] };
        }
        if ((agentChunk?.agent?.messages ?? []).length > 0) {
            const lastMessage = agentChunk.agent.messages[agentChunk.agent.messages.length - 1];
            if (lastMessage.content) {
                let content;
                if (Array.isArray(lastMessage.content)) {
                    content = lastMessage.content
                        .filter((c) => c.type === 'text')
                        .map((b) => b.text)
                        .join('\n');
                }
                else {
                    content = lastMessage.content;
                }
                if (content) {
                    const messageChunk = {
                        role: 'assistant',
                        type: 'message',
                        text: content,
                    };
                    return { messages: [messageChunk] };
                }
                return null;
            }
        }
        if (agentChunk?.process_operations) {
            const update = agentChunk.process_operations;
            if (update.workflowJSON && update.workflowOperations !== undefined) {
                const workflowUpdateChunk = {
                    role: 'assistant',
                    type: 'workflow-updated',
                    codeSnippet: JSON.stringify(update.workflowJSON, null, 2),
                };
                return { messages: [workflowUpdateChunk] };
            }
        }
    }
    else if (streamMode === 'custom') {
        const toolChunk = chunk;
        if (toolChunk?.type === 'tool') {
            const output = { messages: [toolChunk] };
            return output;
        }
    }
    return null;
}
async function* createStreamProcessor(stream) {
    for await (const [streamMode, chunk] of stream) {
        const output = processStreamChunk(streamMode, chunk);
        if (output) {
            yield output;
        }
    }
}
function formatHumanMessage(msg) {
    return {
        role: 'user',
        type: 'message',
        text: msg.content,
    };
}
function processArrayContent(content) {
    const textMessages = content.filter((c) => typeof c === 'object' && c !== null && 'type' in c && c.type === 'text' && 'text' in c);
    return textMessages.map((textMessage) => ({
        role: 'assistant',
        type: 'message',
        text: textMessage.text,
    }));
}
function processAIMessageContent(msg) {
    if (!msg.content) {
        return [];
    }
    if (Array.isArray(msg.content)) {
        return processArrayContent(msg.content);
    }
    return [
        {
            role: 'assistant',
            type: 'message',
            text: msg.content,
        },
    ];
}
function createToolCallMessage(toolCall, builderTool) {
    return {
        id: toolCall.id,
        toolCallId: toolCall.id,
        role: 'assistant',
        type: 'tool',
        toolName: toolCall.name,
        displayTitle: builderTool?.displayTitle,
        customDisplayTitle: toolCall.args && builderTool?.getCustomDisplayTitle?.(toolCall.args),
        status: 'completed',
        updates: [
            {
                type: 'input',
                data: toolCall.args || {},
            },
        ],
    };
}
function processToolCalls(toolCalls, builderTools) {
    return toolCalls.map((toolCall) => {
        const builderTool = builderTools?.find((bt) => bt.toolName === toolCall.name);
        return createToolCallMessage(toolCall, builderTool);
    });
}
function processToolMessage(msg, formattedMessages) {
    const toolCallId = msg.tool_call_id;
    for (let i = formattedMessages.length - 1; i >= 0; i--) {
        const m = formattedMessages[i];
        if (m.type === 'tool' && m.id === toolCallId) {
            m.updates ??= [];
            m.updates.push({
                type: 'output',
                data: typeof msg.content === 'string' ? { result: msg.content } : msg.content,
            });
            break;
        }
    }
}
function formatMessages(messages, builderTools) {
    const formattedMessages = [];
    for (const msg of messages) {
        if (msg instanceof messages_1.HumanMessage) {
            formattedMessages.push(formatHumanMessage(msg));
        }
        else if (msg instanceof messages_1.AIMessage) {
            formattedMessages.push(...processAIMessageContent(msg));
            if (msg.tool_calls?.length) {
                formattedMessages.push(...processToolCalls(msg.tool_calls, builderTools));
            }
        }
        else if (msg instanceof messages_1.ToolMessage) {
            processToolMessage(msg, formattedMessages);
        }
    }
    return formattedMessages;
}
//# sourceMappingURL=stream-processor.js.map