{"version":3,"sources":["../browser/src/driver/sqlite-pooled/SqliteWriteConnection.ts"],"names":[],"mappings":"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","file":"SqliteWriteConnection.js","sourcesContent":["import { captureException } from \"@sentry/node\"\nimport { Database as Sqlite3Database } from \"sqlite3\"\nimport {\n    DbLease,\n    DbLeaseHolder,\n    DbLeaseOwner,\n    SqliteConnectionPool,\n} from \"./SqlitePooledTypes\"\nimport { Mutex, MutexInterface, withTimeout, E_TIMEOUT } from \"async-mutex\"\nimport assert from \"assert\"\nimport { DriverAlreadyReleasedError } from \"../../error/DriverAlreadyReleasedError\"\nimport { SqliteLibrary } from \"./SqliteLibrary\"\nimport { LeasedDbConnection } from \"./LeasedDbConnection\"\nimport { TimeoutTimer } from \"./Timer\"\nimport { InvariantViolatedError } from \"../../error/InvariantViolatedError\"\nimport { LockAcquireTimeoutError } from \"../../error/LockAcquireTimeoutError\"\n\n/**\n * A single write connection to the database.\n */\nexport class SqliteWriteConnection\n    implements SqliteConnectionPool, DbLeaseOwner\n{\n    private writeConnectionPromise: Promise<Sqlite3Database> | null = null\n\n    private isReleased = false\n\n    /**\n     * Mutex to control access to the write connection.\n     */\n    private readonly writeConnectionMutex: MutexInterface\n\n    private dbLease: DbLease | undefined\n\n    constructor(\n        private readonly sqliteLibrary: SqliteLibrary,\n        private readonly options: {\n            acquireTimeout: number\n            destroyTimeout: number\n        },\n    ) {\n        const acquireTimeout = options.acquireTimeout\n\n        this.writeConnectionMutex = withTimeout(new Mutex(), acquireTimeout)\n    }\n\n    public async connect() {\n        this.assertNotReleased()\n\n        await this.writeConnectionMutex.runExclusive(\n            async () => await this.createConnection(),\n        )\n    }\n\n    public async close(): Promise<void> {\n        if (this.isReleased) return\n\n        this.isReleased = true\n\n        // Cancel any pending acquires\n        this.writeConnectionMutex.cancel()\n        // If there is an existing lease, request it to be released\n        if (this.dbLease) {\n            this.dbLease.requestRelease()\n        }\n\n        const timeoutTimer = TimeoutTimer.start(this.options.destroyTimeout)\n        await Promise.race([\n            this.writeConnectionMutex.acquire(),\n            timeoutTimer.promise,\n        ]).finally(() => {\n            timeoutTimer.clear()\n        })\n\n        if (this.writeConnectionPromise) {\n            const dbConnection = await this.writeConnectionPromise\n            this.sqliteLibrary.destroyDatabaseConnection(dbConnection)\n        }\n    }\n\n    public async runExclusive<T>(\n        dbLeaseHolder: DbLeaseHolder,\n        callback: (dbLease: DbLease) => Promise<T>,\n    ): Promise<T> {\n        this.assertNotReleased()\n\n        try {\n            return await this.writeConnectionMutex.runExclusive(async () => {\n                this.dbLease = await this.createAndGetConnection(dbLeaseHolder)\n\n                const result = await callback(this.dbLease).finally(() => {\n                    // runExclusive will make sure the mutex is released. Make\n                    // sure we also mark the lease as released\n                    const dbLease = this.dbLease\n                    this.dbLease = undefined\n\n                    if (dbLease && dbLease.isInvalid) {\n                        this.sqliteLibrary.destroyDatabaseConnection(\n                            dbLease.connection,\n                        )\n                        this.writeConnectionPromise = null\n                    }\n                })\n\n                return result\n            })\n        } catch (error) {\n            if (error === E_TIMEOUT) {\n                captureException(error)\n                this.throwLockTimeoutError(error)\n            }\n\n            throw error\n        }\n    }\n\n    public async leaseConnection(dbLeaseHolder: DbLeaseHolder) {\n        this.assertNotReleased()\n\n        try {\n            await this.writeConnectionMutex.acquire()\n        } catch (error) {\n            captureException(error)\n\n            if (error === E_TIMEOUT) {\n                this.throwLockTimeoutError(error)\n            }\n            throw error\n        }\n\n        this.dbLease = await this.createAndGetConnection(dbLeaseHolder)\n        return this.dbLease\n    }\n\n    public async releaseConnection(leasedDbConnection: DbLease) {\n        if (leasedDbConnection !== this.dbLease) {\n            // Someone is trying to release a connection that is no longer be\n            // the active connection. This is most likely a bug somewhere. In\n            // this case we can't release it, since it might have been already\n            // acquired by someone else. The best we can do is capture the\n            // exception and hope for the best.\n            this.captureInvariantViolated({\n                method: \"releaseConnection\",\n                givenConnectionMatches: this.dbLease === leasedDbConnection,\n                mutexIsLocked: this.writeConnectionMutex.isLocked(),\n                hasWriteConnection: !!this.writeConnectionPromise,\n            })\n            return\n        }\n\n        try {\n            assert(this.writeConnectionPromise)\n            const connection = await this.writeConnectionPromise\n            if (leasedDbConnection.isInvalid) {\n                this.sqliteLibrary.destroyDatabaseConnection(connection)\n                this.writeConnectionPromise = null\n            }\n        } finally {\n            this.dbLease = undefined\n            this.writeConnectionMutex.release()\n        }\n    }\n\n    private async createAndGetConnection(\n        dbLeaseHolder: DbLeaseHolder,\n    ): Promise<LeasedDbConnection> {\n        if (!this.writeConnectionPromise) {\n            this.writeConnectionPromise =\n                this.sqliteLibrary.createDatabaseConnection()\n        }\n\n        const dbConnection = await this.writeConnectionPromise\n\n        assert(!this.dbLease)\n        return new LeasedDbConnection(dbConnection, this, dbLeaseHolder)\n    }\n\n    private async createConnection() {\n        this.assertNotReleased()\n\n        if (this.writeConnectionPromise) {\n            throw new Error(\"Connection already created\")\n        }\n\n        this.writeConnectionPromise =\n            this.sqliteLibrary.createDatabaseConnection()\n        return this.writeConnectionPromise\n    }\n\n    private assertNotReleased() {\n        if (this.isReleased) {\n            throw new DriverAlreadyReleasedError()\n        }\n    }\n\n    private captureInvariantViolated(extra: Record<string, string | boolean>) {\n        const error = new InvariantViolatedError()\n        console.error(\n            \"Invariant violated:\",\n            Object.keys(extra)\n                .map((key) => `${key}=${extra[key]}`)\n                .join(\", \"),\n        )\n        console.error(error)\n        captureException(error, { extra })\n    }\n\n    private throwLockTimeoutError(cause: Error) {\n        throw new LockAcquireTimeoutError(\"SqliteWriteConnectionMutex\", {\n            cause,\n        })\n    }\n}\n"],"sourceRoot":"../.."}