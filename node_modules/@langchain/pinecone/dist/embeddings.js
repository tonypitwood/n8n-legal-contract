/* eslint-disable arrow-body-style */
import { Embeddings } from "@langchain/core/embeddings";
import { getPineconeClient } from "./client.js";
/* PineconeEmbeddings generates embeddings using the Pinecone Inference API. */
export class PineconeEmbeddings extends Embeddings {
    constructor(fields) {
        const defaultFields = { maxRetries: 3, ...fields };
        super(defaultFields);
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "model", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (defaultFields.apiKey) {
            const config = {
                apiKey: defaultFields.apiKey,
                controllerHostUrl: defaultFields.controllerHostUrl,
                fetchApi: defaultFields.fetchApi,
                additionalHeaders: defaultFields.additionalHeaders,
                sourceTag: defaultFields.sourceTag,
            };
            this.client = getPineconeClient(config);
        }
        else {
            this.client = getPineconeClient();
        }
        if (!defaultFields.model) {
            this.model = "multilingual-e5-large";
        }
        else {
            this.model = defaultFields.model;
        }
        const defaultParams = { inputType: "passage" };
        if (defaultFields.params) {
            this.params = { ...defaultFields.params, ...defaultParams };
        }
        else {
            this.params = defaultParams;
        }
    }
    /* Generate embeddings for a list of input strings using a specified embedding model.
     *
     * @param texts - List of input strings for which to generate embeddings.
     * */
    async embedDocuments(texts) {
        if (texts.length === 0) {
            throw new Error("At least one document is required to generate embeddings");
        }
        let embeddings;
        if (this.params) {
            embeddings = await this.caller.call(async () => {
                const result = await this.client.inference.embed(this.model, texts, this.params);
                return result;
            });
        }
        else {
            embeddings = await this.caller.call(async () => {
                const result = await this.client.inference.embed(this.model, texts, {});
                return result;
            });
        }
        const embeddingsList = [];
        for (let i = 0; i < embeddings.data.length; i += 1) {
            const embedding = embeddings.data[i];
            if ("values" in embedding && embedding.values) {
                embeddingsList.push(embedding.values);
            }
        }
        return embeddingsList;
    }
    /* Generate embeddings for a given query string using a specified embedding model.
     * @param text - Query string for which to generate embeddings.
     * */
    async embedQuery(text) {
        // Change inputType to query-specific param for multilingual-e5-large embedding model
        this.params.inputType = "query";
        if (!text) {
            throw new Error("No query passed for which to generate embeddings");
        }
        let embeddings;
        if (this.params) {
            embeddings = await this.caller.call(async () => {
                return await this.client.inference.embed(this.model, [text], this.params);
            });
        }
        else {
            embeddings = await this.caller.call(async () => {
                return await this.client.inference.embed(this.model, [text], {});
            });
        }
        if ("values" in embeddings.data[0]) {
            return embeddings.data[0].values;
        }
        else {
            return [];
        }
    }
}
